["^ ","~:output",["^ ","~:js","goog.provide('promesa.core');\ngoog.require('cljs.core');\ngoog.require('promesa.protocols');\ngoog.require('promesa.impl');\ngoog.require('promesa.impl.scheduler');\npromesa.core.Promise = promesa.impl.Promise;\n/**\n * Schedule a callable to be executed after the `ms` delay\n *   is reached.\n * \n *   In JVM it uses a scheduled executor service and in JS\n *   it uses the `setTimeout` function.\n */\npromesa.core.schedule = (function promesa$core$schedule(ms,func){\nreturn promesa.impl.scheduler.schedule(ms,func);\n});\n/**\n * Return a resolved promise with provided value.\n */\npromesa.core.resolved = (function promesa$core$resolved(v){\nreturn promesa.impl.resolved(v);\n});\n/**\n * Return a rejected promise with provided reason.\n */\npromesa.core.rejected = (function promesa$core$rejected(v){\nreturn promesa.impl.rejected(v);\n});\n/**\n * The promise constructor.\n */\npromesa.core.promise = (function promesa$core$promise(v){\nreturn promesa.protocols._promise(v);\n});\n/**\n * Return true if `v` is a promise instance.\n */\npromesa.core.promise_QMARK_ = (function promesa$core$promise_QMARK_(v){\nreturn (v instanceof promesa.core.Promise);\n});\n/**\n * Returns true if promise `p` is already fulfilled.\n */\npromesa.core.resolved_QMARK_ = (function promesa$core$resolved_QMARK_(p){\nreturn promesa.protocols._resolved_QMARK_(p);\n});\n/**\n * Returns true if promise `p` is already rejected.\n */\npromesa.core.rejected_QMARK_ = (function promesa$core$rejected_QMARK_(p){\nreturn promesa.protocols._rejected_QMARK_(p);\n});\n/**\n * Returns true if promise `p` is stil pending.\n */\npromesa.core.pending_QMARK_ = (function promesa$core$pending_QMARK_(p){\nreturn promesa.protocols._pending_QMARK_(p);\n});\n/**\n * Returns the current promise value.\n */\npromesa.core.extract = (function promesa$core$extract(p){\nreturn promesa.protocols._extract(p);\n});\n/**\n * Returns true if promise `p` is already done.\n */\npromesa.core.done_QMARK_ = cljs.core.complement(promesa.core.pending_QMARK_);\n/**\n * Apply a function to the promise value and\n *   return a new promise with the result.\n */\npromesa.core.map = (function promesa$core$map(f,p){\nreturn promesa.protocols._map(p,f);\n});\n/**\n * Same as `map` but removes one level of\n *   promise neesting. Useful when the map function\n *   returns a promise instead of value.\n * \n *   In JS environment this function is analogous\n *   to `map` because the promise abstraction overloads\n *   the `map` operator.\n */\npromesa.core.mapcat = (function promesa$core$mapcat(f,p){\nreturn promesa.protocols._bind(p,f);\n});\n/**\n * A chain helper for promises.\n */\npromesa.core.bind = (function promesa$core$bind(p,f){\nreturn promesa.protocols._bind(p,f);\n});\n/**\n * Similar to `map` but with parameters inverted\n *   for convenience and for familiarity with\n *   javascript's promises `.then` operator.\n * \n *   Unlike Clojure's `map`, will resolve any promises\n *   returned  by `f`.\n */\npromesa.core.then = (function promesa$core$then(p,f){\nreturn promesa.protocols._map(p,f);\n});\n/**\n * Like then but accepts multiple parameters.\n */\npromesa.core.chain = (function promesa$core$chain(var_args){\nvar args__4534__auto__ = [];\nvar len__4531__auto___16372 = arguments.length;\nvar i__4532__auto___16374 = (0);\nwhile(true){\nif((i__4532__auto___16374 < len__4531__auto___16372)){\nargs__4534__auto__.push((arguments[i__4532__auto___16374]));\n\nvar G__16375 = (i__4532__auto___16374 + (1));\ni__4532__auto___16374 = G__16375;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4535__auto__ = ((((1) < args__4534__auto__.length))?(new cljs.core.IndexedSeq(args__4534__auto__.slice((1)),(0),null)):null);\nreturn promesa.core.chain.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),argseq__4535__auto__);\n});\n\npromesa.core.chain.cljs$core$IFn$_invoke$arity$variadic = (function (p,funcs){\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (p1__16171_SHARP_,p2__16172_SHARP_){\nreturn promesa.core.then(p1__16171_SHARP_,p2__16172_SHARP_);\n}),p,funcs);\n});\n\npromesa.core.chain.cljs$lang$maxFixedArity = (1);\n\n/** @this {Function} */\npromesa.core.chain.cljs$lang$applyTo = (function (seq16174){\nvar G__16175 = cljs.core.first(seq16174);\nvar seq16174__$1 = cljs.core.next(seq16174);\nvar self__4518__auto__ = this;\nreturn self__4518__auto__.cljs$core$IFn$_invoke$arity$variadic(G__16175,seq16174__$1);\n});\n\npromesa.core.branch = (function promesa$core$branch(p,success,failure){\nreturn promesa.protocols._catch(promesa.protocols._map(p,success),failure);\n});\n/**\n * Catch all promise chain helper.\n */\npromesa.core.catch$ = (function promesa$core$catch(var_args){\nvar G__16197 = arguments.length;\nswitch (G__16197) {\ncase 2:\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\npromesa.core.catch$.cljs$core$IFn$_invoke$arity$2 = (function (p,f){\nreturn promesa.protocols._catch(p,f);\n});\n\npromesa.core.catch$.cljs$core$IFn$_invoke$arity$3 = (function (p,pred_or_type,f){\nvar accept_QMARK_ = ((cljs.core.ifn_QMARK_(pred_or_type))?pred_or_type:(function (p1__16192_SHARP_){\nreturn (p1__16192_SHARP_ instanceof pred_or_type);\n}));\nreturn promesa.protocols._catch(p,((function (accept_QMARK_){\nreturn (function (e){\nif(cljs.core.truth_((accept_QMARK_.cljs$core$IFn$_invoke$arity$1 ? accept_QMARK_.cljs$core$IFn$_invoke$arity$1(e) : accept_QMARK_.call(null,e)))){\nreturn (f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(e) : f.call(null,e));\n} else {\nreturn promesa.impl.rejected(e);\n}\n});})(accept_QMARK_))\n);\n});\n\npromesa.core.catch$.cljs$lang$maxFixedArity = 3;\n\n/**\n * Same as `catch` but with parameters inverted.\n */\npromesa.core.error = (function promesa$core$error(var_args){\nvar G__16215 = arguments.length;\nswitch (G__16215) {\ncase 2:\nreturn promesa.core.error.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.error.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\npromesa.core.error.cljs$core$IFn$_invoke$arity$2 = (function (f,p){\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$2(p,f);\n});\n\npromesa.core.error.cljs$core$IFn$_invoke$arity$3 = (function (f,type,p){\nreturn promesa.core.catch$.cljs$core$IFn$_invoke$arity$3(p,type,f);\n});\n\npromesa.core.error.cljs$lang$maxFixedArity = 3;\n\n/**\n * A short alias for `error` function.\n */\npromesa.core.err = promesa.core.error;\n/**\n * Attach handler to promise that will be\n *   executed independently if promise is\n *   resolved or rejected.\n */\npromesa.core.finally$ = (function promesa$core$finally(p,callback){\nreturn p.lastly(callback);\n});\n/**\n * Given an array of promises, return a promise\n *   that is fulfilled  when all the items in the\n *   array are fulfilled.\n * \n *   Example:\n * \n *   (-> (all [(promise :first-promise)\n *          (promise :second-promise)]\n *    (then (fn [[first-result second-result]]))\n *     (println (str first-result \", \" second-result)\n * \n *   Will print out\n *   :first-promise, :second-promise.\n * \n *   If at least one of the promises is rejected, the resulting promise will be\n *   rejected.\n */\npromesa.core.all = (function promesa$core$all(promises){\nreturn promesa.core.then(promesa.core.Promise.all(cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(promises)),cljs.core.vec);\n});\n/**\n * Given an array of promises, return a promise\n *   that is fulfilled when first one item in the\n *   array is fulfilled.\n */\npromesa.core.any = (function promesa$core$any(promises){\nreturn promesa.core.Promise.any(cljs.core.into_array.cljs$core$IFn$_invoke$arity$1(promises));\n});\n/**\n * Cancel the promise.\n */\npromesa.core.cancel_BANG_ = (function promesa$core$cancel_BANG_(p){\npromesa.protocols._cancel(p);\n\nreturn p;\n});\n/**\n * Return true if `v` is a cancelled promise.\n */\npromesa.core.cancelled_QMARK_ = (function promesa$core$cancelled_QMARK_(v){\nreturn promesa.protocols._cancelled_QMARK_(v);\n});\n/**\n * Given a function that accepts a callback as the last argument return other\n *   function that returns a promise. Callback is expected to take single\n *   parameter (result of a computation).\n */\npromesa.core.promisify = (function promesa$core$promisify(callable){\nreturn (function() { \nvar G__16405__delegate = function (args){\nreturn promesa.core.promise((function (resolve,reject){\nvar args__$1 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(cljs.core.vec(args),resolve);\ntry{return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(callable,args__$1);\n}catch (e16293){if((e16293 instanceof Error)){\nvar e = e16293;\nreturn (reject.cljs$core$IFn$_invoke$arity$1 ? reject.cljs$core$IFn$_invoke$arity$1(e) : reject.call(null,e));\n} else {\nthrow e16293;\n\n}\n}}));\n};\nvar G__16405 = function (var_args){\nvar args = null;\nif (arguments.length > 0) {\nvar G__16409__i = 0, G__16409__a = new Array(arguments.length -  0);\nwhile (G__16409__i < G__16409__a.length) {G__16409__a[G__16409__i] = arguments[G__16409__i + 0]; ++G__16409__i;}\n  args = new cljs.core.IndexedSeq(G__16409__a,0,null);\n} \nreturn G__16405__delegate.call(this,args);};\nG__16405.cljs$lang$maxFixedArity = 0;\nG__16405.cljs$lang$applyTo = (function (arglist__16418){\nvar args = cljs.core.seq(arglist__16418);\nreturn G__16405__delegate(args);\n});\nG__16405.cljs$core$IFn$_invoke$arity$variadic = G__16405__delegate;\nreturn G__16405;\n})()\n;\n});\n/**\n * Returns a cancellable promise that will be fulfilled\n *   with this promise's fulfillment value or rejection reason.\n *   However, if this promise is not fulfilled or rejected\n *   within `ms` milliseconds, the returned promise is cancelled\n *   with a TimeoutError\n */\npromesa.core.timeout = (function promesa$core$timeout(var_args){\nvar G__16313 = arguments.length;\nswitch (G__16313) {\ncase 2:\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn promesa.core.timeout.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\npromesa.core.timeout.cljs$core$IFn$_invoke$arity$2 = (function (p,t){\nreturn p.timeout(t);\n});\n\npromesa.core.timeout.cljs$core$IFn$_invoke$arity$3 = (function (p,t,v){\nreturn p.timeout(t,v);\n});\n\npromesa.core.timeout.cljs$lang$maxFixedArity = 3;\n\n/**\n * Given a timeout in miliseconds and optional\n *   value, returns a promise that will fulfilled\n *   with provided value (or nil) after the\n *   time is reached.\n */\npromesa.core.delay = (function promesa$core$delay(var_args){\nvar G__16318 = arguments.length;\nswitch (G__16318) {\ncase 1:\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));\n\nbreak;\ncase 2:\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\npromesa.core.delay.cljs$core$IFn$_invoke$arity$1 = (function (t){\nreturn promesa.core.delay.cljs$core$IFn$_invoke$arity$2(t,null);\n});\n\npromesa.core.delay.cljs$core$IFn$_invoke$arity$2 = (function (t,v){\nreturn promesa.core.promise((function (resolve,reject){\nreturn promesa.core.schedule(t,(function (){\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(v) : resolve.call(null,v));\n}));\n}));\n});\n\npromesa.core.delay.cljs$lang$maxFixedArity = 2;\n\n/**\n * A helper for start promise chain without worry about\n *   synchronous or asynchronous exceptions. Returns a promise\n *   resolved with the return value of the callback.\n */\npromesa.core.attempt = (function promesa$core$attempt(callback){\nreturn promesa.core.promise((function (resolve){\nvar G__16324 = (callback.cljs$core$IFn$_invoke$arity$0 ? callback.cljs$core$IFn$_invoke$arity$0() : callback.call(null));\nreturn (resolve.cljs$core$IFn$_invoke$arity$1 ? resolve.cljs$core$IFn$_invoke$arity$1(G__16324) : resolve.call(null,G__16324));\n}));\n});\npromesa.core.await$ = (function promesa$core$await(var_args){\nvar args__4534__auto__ = [];\nvar len__4531__auto___16432 = arguments.length;\nvar i__4532__auto___16440 = (0);\nwhile(true){\nif((i__4532__auto___16440 < len__4531__auto___16432)){\nargs__4534__auto__.push((arguments[i__4532__auto___16440]));\n\nvar G__16441 = (i__4532__auto___16440 + (1));\ni__4532__auto___16440 = G__16441;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4535__auto__ = ((((0) < args__4534__auto__.length))?(new cljs.core.IndexedSeq(args__4534__auto__.slice((0)),(0),null)):null);\nreturn promesa.core.await$.cljs$core$IFn$_invoke$arity$variadic(argseq__4535__auto__);\n});\n\npromesa.core.await$.cljs$core$IFn$_invoke$arity$variadic = (function (args){\nthrow cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2(\"Should be only used in alet macro.\",cljs.core.PersistentArrayMap.EMPTY);\n});\n\npromesa.core.await$.cljs$lang$maxFixedArity = (0);\n\n/** @this {Function} */\npromesa.core.await$.cljs$lang$applyTo = (function (seq16328){\nvar self__4519__auto__ = this;\nreturn self__4519__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq16328));\n});\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","promesa/core.cljc","~:line",25,"~:column",5,"~:end-line",25,"~:end-column",17],"~:ns-aliases",["^ ","~$clojure.core.async","~$cljs.core.async","~$raspicam","~$shadow.js.shim.module$raspicam"],"~:use-macros",null,"~:excludes",["~#set",["~$map","~$delay","~$mapcat","~$await","~$spread","~$promise"]],"~:name","~$promesa.core","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$promesa.protocols","^O","~$pt","^O","~$promesa.impl","^Q","~$impl","^Q","~$promesa.impl.scheduler","^S","~$ps","^S","~$cljs.core","^U","~$goog","^V"],"~:seen",["^B",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^U","^U"],"~:form",["~#list",["~$ns","^J",["^10",["~:refer-clojure","~:exclude",["^D","^G","^H","^F","^C","^E"]]],["^10",["^X",["^O","~:as","^P"],["^Q","^14","^R"],["^S","^14","^T"]]]]],"~:flags",["^ ","^X",["^B",[]]],"~:js-deps",["^ "],"~:deps",["^V","^U","^O","^Q","^S"]],"^L","^J","~:resource-id",["~:shadow.build.classpath/resource","promesa/core.cljc"],"~:compiled-at",1540144996140,"~:resource-name","promesa/core.cljc","~:warnings",[],"~:source",";; Copyright (c) 2015-2016 Andrey Antukh <niwi@niwi.nz>\n;; All rights reserved.\n;;\n;; Redistribution and use in source and binary forms, with or without\n;; modification, are permitted provided that the following conditions\n;; are met:\n;;\n;; 1. Redistributions of source code must retain the above copyright\n;;    notice, this list of conditions and the following disclaimer.\n;; 2. Redistributions in binary form must reproduce the above copyright\n;;    notice, this list of conditions and the following disclaimer in the\n;;    documentation and/or other materials provided with the distribution.\n;;\n;; THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR\n;; IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES\n;; OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n;; IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,\n;; INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n;; NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n;; DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n;; THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n;; (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n;; THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n(ns promesa.core\n  (:refer-clojure :exclude [delay spread promise await map mapcat])\n  (:require [promesa.protocols :as pt]\n            [promesa.impl :as impl]\n            [promesa.impl.scheduler :as ps])\n  #?(:clj\n     (:import java.util.concurrent.CompletableFuture\n              java.util.concurrent.CompletionStage)))\n\n;; --- Global Constants\n\n#?(:clj\n   (defn set-executor!\n     \"Replace the default executor instance with\n     your own instance.\"\n     [executor]\n     (alter-var-root #'impl/+executor+ (constantly executor))))\n\n#?(:cljs (def ^:const Promise impl/Promise))\n\n;; --- Scheduling helpers\n\n(defn schedule\n  \"Schedule a callable to be executed after the `ms` delay\n  is reached.\n\n  In JVM it uses a scheduled executor service and in JS\n  it uses the `setTimeout` function.\"\n  [ms func]\n  (ps/schedule ms func))\n\n;; --- Promise\n\n(defn resolved\n  \"Return a resolved promise with provided value.\"\n  [v]\n  (impl/resolved v))\n\n(defn rejected\n  \"Return a rejected promise with provided reason.\"\n  [v]\n  (impl/rejected v))\n\n(defn promise\n  \"The promise constructor.\"\n  [v]\n  (pt/-promise v))\n\n(defn promise?\n  \"Return true if `v` is a promise instance.\"\n  [v]\n  #?(:clj (instance? CompletionStage v)\n     :cljs (instance? Promise v)))\n\n;; Predicates\n\n(defn resolved?\n  \"Returns true if promise `p` is already fulfilled.\"\n  [p]\n  (pt/-resolved? p))\n\n(defn rejected?\n  \"Returns true if promise `p` is already rejected.\"\n  [p]\n  (pt/-rejected? p))\n\n(defn pending?\n  \"Returns true if promise `p` is stil pending.\"\n  [p]\n  (pt/-pending? p))\n\n(defn extract\n  \"Returns the current promise value.\"\n  [p]\n  (pt/-extract p))\n\n(def done?\n  \"Returns true if promise `p` is already done.\"\n  (complement pending?))\n\n;; Chaining\n\n(defn map\n  \"Apply a function to the promise value and\n  return a new promise with the result.\"\n  [f p]\n  (pt/-map p f))\n\n(defn mapcat\n  \"Same as `map` but removes one level of\n  promise neesting. Useful when the map function\n  returns a promise instead of value.\n\n  In JS environment this function is analogous\n  to `map` because the promise abstraction overloads\n  the `map` operator.\"\n  [f p]\n  (pt/-bind p f))\n\n(defn bind\n  \"A chain helper for promises.\"\n  [p f]\n  (pt/-bind p f))\n\n(defn then\n  \"Similar to `map` but with parameters inverted\n  for convenience and for familiarity with\n  javascript's promises `.then` operator.\n\n  Unlike Clojure's `map`, will resolve any promises\n  returned  by `f`.\"\n  [p f]\n  #?(:cljs (pt/-map p f)\n     :clj  (pt/-bind p (fn promise-wrap [in]\n                         (let [out (f in)]\n                           (if (promise? out)\n                             out\n                             (promise out)))))))\n\n(defn chain\n  \"Like then but accepts multiple parameters.\"\n  [p & funcs]\n  (reduce #(then %1 %2) p funcs))\n\n(defn branch\n  [p success failure]\n  (-> p\n      (pt/-map success)\n      (pt/-catch failure)))\n\n(defn catch\n  \"Catch all promise chain helper.\"\n  ([p f]\n   (pt/-catch p f))\n  ([p pred-or-type f]\n   (let [accept? (if (ifn? pred-or-type)\n                   pred-or-type\n                   #(instance? pred-or-type %))]\n     (pt/-catch p (fn [e]\n                    (if (accept? e)\n                      (f e)\n                      (impl/rejected e)))))))\n\n(defn error\n  \"Same as `catch` but with parameters inverted.\"\n  ([f p] (catch p f))\n  ([f type p] (catch p type f)))\n\n(def err\n  \"A short alias for `error` function.\"\n  error)\n\n(defn finally\n  \"Attach handler to promise that will be\n  executed independently if promise is\n  resolved or rejected.\"\n  [p callback]\n  #?(:clj (-> p\n              (then (fn [_] (callback)))\n              (catch (fn [_] (callback))))\n     :cljs (.lastly p callback)))\n\n(defn all\n  \"Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \\\", \\\" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected.\"\n  [promises]\n  #?(:cljs (-> (.all Promise (into-array promises))\n               (then vec))\n     :clj (let [promises (clojure.core/map pt/-promise promises)]\n            (then (->> (into-array CompletableFuture promises)\n                       (CompletableFuture/allOf))\n                  (fn [_]\n                    (mapv pt/-extract promises))))))\n\n(defn any\n  \"Given an array of promises, return a promise\n  that is fulfilled when first one item in the\n  array is fulfilled.\"\n  [promises]\n  #?(:cljs (.any Promise (into-array promises))\n     :clj (->> (clojure.core/map pt/-promise promises)\n               (into-array CompletableFuture)\n               (CompletableFuture/anyOf))))\n\n;; Cancellation\n\n(defn cancel!\n  \"Cancel the promise.\"\n  [p]\n  (pt/-cancel p)\n  p)\n\n(defn cancelled?\n  \"Return true if `v` is a cancelled promise.\"\n  [v]\n  (pt/-cancelled? v))\n\n;; Utils\n\n(defn promisify\n  \"Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation).\"\n  [callable]\n  (fn [& args]\n    (promise (fn [resolve reject]\n               (let [args (-> (vec args)\n                              (conj resolve))]\n                 (try\n                   (apply callable args)\n                   (catch #?(:clj Throwable :cljs js/Error) e\n                       (reject e))))))))\n\n#?(:cljs\n   (defn timeout\n     \"Returns a cancellable promise that will be fulfilled\n     with this promise's fulfillment value or rejection reason.\n     However, if this promise is not fulfilled or rejected\n     within `ms` milliseconds, the returned promise is cancelled\n     with a TimeoutError\"\n     ([p t] (.timeout p t))\n     ([p t v] (.timeout p t v))))\n\n(defn delay\n  \"Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached.\"\n  ([t] (delay t nil))\n  ([t v]\n   #?(:cljs (promise (fn [resolve reject]\n                       (schedule t #(resolve v))))\n\n      :clj  (let [p (CompletableFuture.)]\n              (schedule t #(.complete p v))\n              p))))\n\n(defn attempt\n  \"A helper for start promise chain without worry about\n  synchronous or asynchronous exceptions. Returns a promise\n  resolved with the return value of the callback.\"\n  [callback]\n  #?(:cljs (promise (fn [resolve] (resolve (callback))))\n     :clj  (promise (fn [resolve reject]\n                      (let [result (callback)]\n                        (if (promise? result)\n                          (then result resolve)\n                          (resolve result)))))))\n\n#?(:clj\n   (defmacro do*\n     \"A sugar syntax on top of `attempt`.\"\n     [& body]\n     `(attempt #(do ~@body))))\n\n(defn await\n  [& args]\n  (throw (ex-info \"Should be only used in alet macro.\" {})))\n\n#?(:clj\n   (defmacro alet\n     \"A `let` alternative that always returns promise and allows\n     use `await` marker function in order to emulate the async/await\n     syntax and make the let expression look like synchronous where\n     async operations are performed.\"\n     [bindings & body]\n     (let [await# `await]\n       (->> (reverse (partition 2 bindings))\n            (reduce (fn [acc [l r]]\n                      (if (and (coll? r)\n                               (symbol? (first r))\n                               (not= \".\" (subs (name (first r)) 0 1)))\n                        `(if (= ~await# ~(first r))\n                           (bind ~(second r) (fn [~l] ~acc))\n                           (let [~l ~r] ~acc))\n                        `(let [~l ~r] ~acc)))\n                    `(promise (do ~@body)))))))\n","~:reader-features",["^B",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["promesa.core/Promise","promesa.impl/Promise","promesa.core/schedule","ms","func","promesa.impl.scheduler/schedule","promesa.core/resolved","v","promesa.impl/resolved","promesa.core/rejected","promesa.impl/rejected","promesa.core/promise","promesa.protocols/-promise","promesa.core/promise?","promesa.core/resolved?","p","promesa.protocols/-resolved?","promesa.core/rejected?","promesa.protocols/-rejected?","promesa.core/pending?","promesa.protocols/-pending?","promesa.core/extract","promesa.protocols/-extract","promesa.core/done?","cljs.core/complement","promesa.core/map","f","promesa.protocols/-map","promesa.core/mapcat","promesa.protocols/-bind","promesa.core/bind","promesa.core/then","var_args","args__4534__auto__","len__4531__auto__","i__4532__auto__","argseq__4535__auto__","cljs.core/IndexedSeq","promesa.core/chain","seq16174","G__16175","cljs.core/first","cljs.core/next","self__4518__auto__","funcs","p1__16171#","p2__16172#","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","promesa.core/branch","success","failure","promesa.protocols/-catch","G__16197","promesa.core/catch","js/Error","pred-or-type","accept?","p1__16192#","cljs.core/ifn?","e","G__16215","promesa.core/error","promesa.core.catch$.cljs$core$IFn$_invoke$arity$2","type","promesa.core.catch$.cljs$core$IFn$_invoke$arity$3","promesa.core/err","promesa.core/finally","callback","promesa.core/all","promises","cljs.core.into_array.cljs$core$IFn$_invoke$arity$1","cljs.core/vec","promesa.core/any","promesa.core/cancel!","promesa.protocols/-cancel","promesa.core/cancelled?","promesa.protocols/-cancelled?","promesa.core/promisify","callable","args","resolve","reject","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","e16293","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","G__16313","promesa.core/timeout","t","G__16318","promesa.core/delay","promesa.core.delay.cljs$core$IFn$_invoke$arity$2","promesa.core/attempt","G__16324","promesa.core/await","seq16328","self__4519__auto__","cljs.core/seq","cljs.core.ex_info.cljs$core$IFn$_invoke$arity$2"]]],"~:cache-keys",["~#cmap",[["~:macro","^U"],[1534380137000],["^19","goog/math/math.js"],[1530991559994,"^V","~$goog.array","~$goog.asserts"],["^19","goog/array/array.js"],[1530991559994,"^V","^1H"],["^19","goog/debug/error.js"],[1530991559994,"^V"],["^19","promesa/impl/scheduler.cljc"],[1535586406328,"^V","^U","^O"],["^19","promesa/impl.cljc"],[1535586406328,"^V","^U","^O","~$org.bluebird"],["^19","goog/dom/nodetype.js"],[1530991559994,"^V"],["^19","goog/object/object.js"],[1530991559994,"^V"],"~:SHADOW-TIMESTAMP",[1540077702000,1534380137000],["^19","goog/math/long.js"],[1530991559994,"^V","^1H","~$goog.reflect"],["^19","goog/functions/functions.js"],[1530991559994,"^V"],["^19","goog/structs/map.js"],[1530991559994,"^V","~$goog.iter.Iterator","~$goog.iter.StopIteration","~$goog.object"],["~:shadow.build.js-support/require","bluebird"],["~$shadow.js.shim.module$bluebird","shadow.js.shim.module$bluebird.js","^V"],["^19","goog/asserts/asserts.js"],[1530991559994,"^V","~$goog.debug.Error","~$goog.dom.NodeType","~$goog.string"],["^19","goog/uri/uri.js"],[1530991559994,"^V","^1G","^1H","^1S","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"],["^19","goog/base.js"],[1530991559994],["^19","promesa/core.cljc"],[1535586406328,"^V","^U","^O","^Q","^S"],["^19","goog/structs/structs.js"],[1530991559994,"^V","^1G","^1N"],["^19","org/bluebird.cljs"],[1535669979047,"^V","^U","^1P"],["^19","goog/string/string.js"],[1530991559994,"^V"],["^19","goog/reflect/reflect.js"],[1530991559994,"^V"],["^19","goog/string/stringbuffer.js"],[1530991559994,"^V"],["^19","promesa/protocols.cljc"],[1535586406328,"^V","^U"],["^19","goog/iter/iter.js"],[1530991559994,"^V","^1G","^1H","~$goog.functions","~$goog.math"],["^19","cljs/core.cljs"],[1534380137690,"~$goog.math.Long","~$goog.math.Integer","^1S","^1N","^1G","~$goog.Uri","~$goog.string.StringBuffer"],["^19","goog/math/integer.js"],[1530991559994,"^V"],["^19","goog/uri/utils.js"],[1530991559994,"^V","^1G","^1H","^1S"]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","promesa/core.cljc","^7",25,"^8",5,"^9",25,"^:",17],"^;",["^ ","^<","^=","^>","^?"],"^@",null,"^A",["^B",["^C","^D","^E","^F","^G","^H"]],"~:shadow/js-access-properties",["^B",["any"]],"^I","^J","^M",null,"^N",["^ ","^O","^O","^P","^O","^Q","^Q","^R","^Q","^S","^S","^T","^S","^U","^U","^V","^V"],"^W",["^B",["^X"]],"~:shadow/js-access-global",["^B",["Error"]],"^Y",null,"~:defs",["^ ","~$timeout",["^ ","~:protocol-inline",null,"^5",["^ ","^6","promesa/core.cljc","^7",253,"^8",10,"^9",253,"^:",17,"~:arglists",["^10",["~$quote",["^10",[["~$p","~$t"],["~$p","~$t","~$v"]]]]],"~:doc","Returns a cancellable promise that will be fulfilled\n     with this promise's fulfillment value or rejection reason.\n     However, if this promise is not fulfilled or rejected\n     within `ms` milliseconds, the returned promise is cancelled\n     with a TimeoutError","~:top-fn",["^ ","~:variadic",false,"~:max-fixed-arity",3,"~:method-params",["^10",[["~$p","~$t"],["~$p","~$t","~$v"]]],"^29",["^10",[["~$p","~$t"],["~$p","~$t","~$v"]]],"~:arglists-meta",["^10",[null,null]]]],"^I","~$promesa.core/timeout","^2=",false,"^6","promesa/core.cljc","^:",17,"^2<",["^ ","^2=",false,"^2>",3,"^2?",["^10",[["~$p","~$t"],["~$p","~$t","~$v"]]],"^29",["^10",[["~$p","~$t"],["~$p","~$t","~$v"]]],"^2@",["^10",[null,null]]],"^2?",["^10",[["~$p","~$t"],["~$p","~$t","~$v"]]],"~:protocol-impl",null,"^2@",["^10",[null,null]],"^8",4,"^7",253,"^9",253,"^2>",3,"~:fn-var",true,"^29",["^10",[["~$p","~$t"],["~$p","~$t","~$v"]]],"^2;","Returns a cancellable promise that will be fulfilled\n     with this promise's fulfillment value or rejection reason.\n     However, if this promise is not fulfilled or rejected\n     within `ms` milliseconds, the returned promise is cancelled\n     with a TimeoutError"],"~$Promise",["^ ","^I","~$promesa.core/Promise","^6","promesa/core.cljc","^7",43,"^8",10,"^9",43,"^:",30,"~:const",true,"^5",["^ ","^6","promesa/core.cljc","^7",43,"^8",23,"^9",43,"^:",30,"^2F",true],"~:tag","~$js"],"~$branch",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",149,"^8",7,"^9",149,"^:",13,"^29",["^10",["^2:",["^10",[["~$p","~$success","~$failure"]]]]]],"^I","~$promesa.core/branch","^2=",false,"^6","promesa/core.cljc","^:",13,"^2?",["^10",[["~$p","^2J","^2K"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",149,"^9",149,"^2>",3,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p","^2J","^2K"]]]]]],"~$attempt",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",276,"^8",7,"^9",276,"^:",14,"^29",["^10",["^2:",["^10",[["~$callback"]]]]],"^2;","A helper for start promise chain without worry about\n  synchronous or asynchronous exceptions. Returns a promise\n  resolved with the return value of the callback."],"^I","~$promesa.core/attempt","^2=",false,"^6","promesa/core.cljc","^:",14,"^2?",["^10",[["^2N"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",276,"^9",276,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["^2N"]]]]],"^2;","A helper for start promise chain without worry about\n  synchronous or asynchronous exceptions. Returns a promise\n  resolved with the return value of the callback."],"^C",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",107,"^8",7,"^9",107,"^:",10,"^29",["^10",["^2:",["^10",[["~$f","~$p"]]]]],"^2;","Apply a function to the promise value and\n  return a new promise with the result."],"^I","~$promesa.core/map","^2=",false,"^6","promesa/core.cljc","^:",10,"^2?",["^10",[["~$f","~$p"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",107,"^9",107,"^2>",2,"^2C",true,"^29",["^10",["^2:",["^10",[["~$f","~$p"]]]]],"^2;","Apply a function to the promise value and\n  return a new promise with the result."],"^D",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",262,"^8",7,"^9",262,"^:",12,"^29",["^10",["^2:",["^10",[["~$t"],["~$t","~$v"]]]]],"^2;","Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached.","^2<",["^ ","^2=",false,"^2>",2,"^2?",["^10",[["~$t"],["~$t","~$v"]]],"^29",["^10",[["~$t"],["~$t","~$v"]]],"^2@",["^10",[null,null]]]],"^I","~$promesa.core/delay","^2=",false,"^6","promesa/core.cljc","^:",12,"^2<",["^ ","^2=",false,"^2>",2,"^2?",["^10",[["~$t"],["~$t","~$v"]]],"^29",["^10",[["~$t"],["~$t","~$v"]]],"^2@",["^10",[null,null]]],"^2?",["^10",[["~$t"],["~$t","~$v"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",262,"^9",262,"^2>",2,"^2C",true,"^29",["^10",[["~$t"],["~$t","~$v"]]],"^2;","Given a timeout in miliseconds and optional\n  value, returns a promise that will fulfilled\n  with provided value (or nil) after the\n  time is reached."],"~$resolved?",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",81,"^8",7,"^9",81,"^:",16,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Returns true if promise `p` is already fulfilled."],"^I","~$promesa.core/resolved?","^2=",false,"^6","promesa/core.cljc","^:",16,"^2?",["^10",[["~$p"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",81,"^9",81,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Returns true if promise `p` is already fulfilled."],"^E",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",113,"^8",7,"^9",113,"^:",13,"^29",["^10",["^2:",["^10",[["~$f","~$p"]]]]],"^2;","Same as `map` but removes one level of\n  promise neesting. Useful when the map function\n  returns a promise instead of value.\n\n  In JS environment this function is analogous\n  to `map` because the promise abstraction overloads\n  the `map` operator."],"^I","~$promesa.core/mapcat","^2=",false,"^6","promesa/core.cljc","^:",13,"^2?",["^10",[["~$f","~$p"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",113,"^9",113,"^2>",2,"^2C",true,"^29",["^10",["^2:",["^10",[["~$f","~$p"]]]]],"^2;","Same as `map` but removes one level of\n  promise neesting. Useful when the map function\n  returns a promise instead of value.\n\n  In JS environment this function is analogous\n  to `map` because the promise abstraction overloads\n  the `map` operator."],"~$cancelled?",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",231,"^8",7,"^9",231,"^:",17,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","Return true if `v` is a cancelled promise."],"^I","~$promesa.core/cancelled?","^2=",false,"^6","promesa/core.cljc","^:",17,"^2?",["^10",[["~$v"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",231,"^9",231,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","Return true if `v` is a cancelled promise."],"^F",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",294,"^8",7,"^9",294,"^:",12,"^29",["^10",["^2:",["^10",[["~$&","~$args"]]]]],"^2<",["^ ","^2=",true,"^2>",0,"^2?",[["^10",["^2W"]]],"^29",["^10",[["~$&","^2W"]]],"^2@",["^10",[null]]]],"^I","~$promesa.core/await","^2=",true,"^6","promesa/core.cljc","^:",12,"^2<",["^ ","^2=",true,"^2>",0,"^2?",[["^10",["^2W"]]],"^29",["^10",[["~$&","^2W"]]],"^2@",["^10",[null]]],"^2?",[["^10",["^2W"]]],"^2B",null,"^2@",["^10",[null]],"^8",1,"^7",294,"^9",294,"^2>",0,"^2C",true,"^29",["^10",[["~$&","^2W"]]]],"~$bind",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",124,"^8",7,"^9",124,"^:",11,"^29",["^10",["^2:",["^10",[["~$p","~$f"]]]]],"^2;","A chain helper for promises."],"^I","~$promesa.core/bind","^2=",false,"^6","promesa/core.cljc","^:",11,"^2?",["^10",[["~$p","~$f"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",124,"^9",124,"^2>",2,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p","~$f"]]]]],"^2;","A chain helper for promises."],"~$any",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",213,"^8",7,"^9",213,"^:",10,"^29",["^10",["^2:",["^10",[["~$promises"]]]]],"^2;","Given an array of promises, return a promise\n  that is fulfilled when first one item in the\n  array is fulfilled."],"^I","~$promesa.core/any","^2=",false,"^6","promesa/core.cljc","^:",10,"^2?",["^10",[["^30"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",213,"^9",213,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["^30"]]]]],"^2;","Given an array of promises, return a promise\n  that is fulfilled when first one item in the\n  array is fulfilled."],"~$finally",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",177,"^8",7,"^9",177,"^:",14,"^29",["^10",["^2:",["^10",[["~$p","^2N"]]]]],"^2;","Attach handler to promise that will be\n  executed independently if promise is\n  resolved or rejected."],"^I","~$promesa.core/finally","^2=",false,"^6","promesa/core.cljc","^:",14,"^2?",["^10",[["~$p","^2N"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",177,"^9",177,"^2>",2,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p","^2N"]]]]],"^2;","Attach handler to promise that will be\n  executed independently if promise is\n  resolved or rejected."],"~$schedule",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",47,"^8",7,"^9",47,"^:",15,"^29",["^10",["^2:",["^10",[["~$ms","~$func"]]]]],"^2;","Schedule a callable to be executed after the `ms` delay\n  is reached.\n\n  In JVM it uses a scheduled executor service and in JS\n  it uses the `setTimeout` function."],"^I","~$promesa.core/schedule","^2=",false,"^6","promesa/core.cljc","^:",15,"^2?",["^10",[["^35","^36"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",47,"^9",47,"^2>",2,"^2C",true,"^29",["^10",["^2:",["^10",[["^35","^36"]]]]],"^2;","Schedule a callable to be executed after the `ms` delay\n  is reached.\n\n  In JVM it uses a scheduled executor service and in JS\n  it uses the `setTimeout` function."],"~$promisify",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",238,"^8",7,"^9",238,"^:",16,"^29",["^10",["^2:",["^10",[["~$callable"]]]]],"^2;","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"^I","~$promesa.core/promisify","^2=",false,"^6","promesa/core.cljc","^:",16,"^2?",["^10",[["^39"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",238,"^9",238,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["^39"]]]]],"^2;","Given a function that accepts a callback as the last argument return other\n  function that returns a promise. Callback is expected to take single\n  parameter (result of a computation)."],"~$rejected",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",63,"^8",7,"^9",63,"^:",15,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","Return a rejected promise with provided reason."],"^I","~$promesa.core/rejected","^2=",false,"^6","promesa/core.cljc","^:",15,"^2?",["^10",[["~$v"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",63,"^9",63,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","Return a rejected promise with provided reason."],"^H",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",68,"^8",7,"^9",68,"^:",14,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","The promise constructor."],"^I","~$promesa.core/promise","^2=",false,"^6","promesa/core.cljc","^:",14,"^2?",["^10",[["~$v"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",68,"^9",68,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","The promise constructor."],"~$cancel!",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",225,"^8",7,"^9",225,"^:",14,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Cancel the promise."],"^I","~$promesa.core/cancel!","^2=",false,"^6","promesa/core.cljc","^:",14,"^2?",["^10",[["~$p"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",225,"^9",225,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Cancel the promise."],"~$done?",["^ ","^I","~$promesa.core/done?","^6","promesa/core.cljc","^7",101,"^8",1,"^9",101,"^:",11,"^5",["^ ","^6","promesa/core.cljc","^7",101,"^8",6,"^9",101,"^:",11],"^2;","Returns true if promise `p` is already done.","^2G","^2["],"~$err",["^ ","^I","~$promesa.core/err","^6","promesa/core.cljc","^7",173,"^8",1,"^9",173,"^:",9,"^5",["^ ","^6","promesa/core.cljc","^7",173,"^8",6,"^9",173,"^:",9],"^2;","A short alias for `error` function."],"~$all",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",187,"^8",7,"^9",187,"^:",10,"^29",["^10",["^2:",["^10",[["^30"]]]]],"^2;","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"^I","~$promesa.core/all","^2=",false,"^6","promesa/core.cljc","^:",10,"^2?",["^10",[["^30"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",187,"^9",187,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["^30"]]]]],"^2;","Given an array of promises, return a promise\n  that is fulfilled  when all the items in the\n  array are fulfilled.\n\n  Example:\n\n  (-> (all [(promise :first-promise)\n            (promise :second-promise)]\n      (then (fn [[first-result second-result]]))\n       (println (str first-result \", \" second-result)\n\n  Will print out\n  :first-promise, :second-promise.\n\n  If at least one of the promises is rejected, the resulting promise will be\n  rejected."],"~$promise?",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",73,"^8",7,"^9",73,"^:",15,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","Return true if `v` is a promise instance."],"^I","~$promesa.core/promise?","^2=",false,"^6","promesa/core.cljc","^:",15,"^2?",["^10",[["~$v"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",73,"^9",73,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","Return true if `v` is a promise instance."],"~$resolved",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",58,"^8",7,"^9",58,"^:",15,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","Return a resolved promise with provided value."],"^I","~$promesa.core/resolved","^2=",false,"^6","promesa/core.cljc","^:",15,"^2?",["^10",[["~$v"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",58,"^9",58,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$v"]]]]],"^2;","Return a resolved promise with provided value."],"~$catch",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",155,"^8",7,"^9",155,"^:",12,"^29",["^10",["^2:",["^10",[["~$p","~$f"],["~$p","~$pred-or-type","~$f"]]]]],"^2;","Catch all promise chain helper.","^2<",["^ ","^2=",false,"^2>",3,"^2?",["^10",[["~$p","~$f"],["~$p","^3K","~$f"]]],"^29",["^10",[["~$p","~$f"],["~$p","^3K","~$f"]]],"^2@",["^10",[null,null]]]],"^I","~$promesa.core/catch","^2=",false,"^6","promesa/core.cljc","^:",12,"^2<",["^ ","^2=",false,"^2>",3,"^2?",["^10",[["~$p","~$f"],["~$p","^3K","~$f"]]],"^29",["^10",[["~$p","~$f"],["~$p","^3K","~$f"]]],"^2@",["^10",[null,null]]],"^2?",["^10",[["~$p","~$f"],["~$p","^3K","~$f"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",155,"^9",155,"^2>",3,"^2C",true,"^29",["^10",[["~$p","~$f"],["~$p","^3K","~$f"]]],"^2;","Catch all promise chain helper."],"~$chain",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",144,"^8",7,"^9",144,"^:",12,"^29",["^10",["^2:",["^10",[["~$p","~$&","~$funcs"]]]]],"^2;","Like then but accepts multiple parameters.","^2<",["^ ","^2=",true,"^2>",1,"^2?",[["^10",["~$p","^3N"]]],"^29",["^10",[["~$p","~$&","^3N"]]],"^2@",["^10",[null]]]],"^I","~$promesa.core/chain","^2=",true,"^6","promesa/core.cljc","^:",12,"^2<",["^ ","^2=",true,"^2>",1,"^2?",[["^10",["~$p","^3N"]]],"^29",["^10",[["~$p","~$&","^3N"]]],"^2@",["^10",[null]]],"^2?",[["^10",["~$p","^3N"]]],"^2B",null,"^2@",["^10",[null]],"^8",1,"^7",144,"^9",144,"^2>",1,"^2C",true,"^29",["^10",[["~$p","~$&","^3N"]]],"^2;","Like then but accepts multiple parameters."],"~$rejected?",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",86,"^8",7,"^9",86,"^:",16,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Returns true if promise `p` is already rejected."],"^I","~$promesa.core/rejected?","^2=",false,"^6","promesa/core.cljc","^:",16,"^2?",["^10",[["~$p"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",86,"^9",86,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Returns true if promise `p` is already rejected."],"~$then",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",129,"^8",7,"^9",129,"^:",11,"^29",["^10",["^2:",["^10",[["~$p","~$f"]]]]],"^2;","Similar to `map` but with parameters inverted\n  for convenience and for familiarity with\n  javascript's promises `.then` operator.\n\n  Unlike Clojure's `map`, will resolve any promises\n  returned  by `f`."],"^I","~$promesa.core/then","^2=",false,"^6","promesa/core.cljc","^:",11,"^2?",["^10",[["~$p","~$f"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",129,"^9",129,"^2>",2,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p","~$f"]]]]],"^2;","Similar to `map` but with parameters inverted\n  for convenience and for familiarity with\n  javascript's promises `.then` operator.\n\n  Unlike Clojure's `map`, will resolve any promises\n  returned  by `f`."],"~$extract",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",96,"^8",7,"^9",96,"^:",14,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Returns the current promise value."],"^I","~$promesa.core/extract","^2=",false,"^6","promesa/core.cljc","^:",14,"^2?",["^10",[["~$p"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",96,"^9",96,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Returns the current promise value."],"~$error",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",168,"^8",7,"^9",168,"^:",12,"^29",["^10",["^2:",["^10",[["~$f","~$p"],["~$f","~$type","~$p"]]]]],"^2;","Same as `catch` but with parameters inverted.","^2<",["^ ","^2=",false,"^2>",3,"^2?",["^10",[["~$f","~$p"],["~$f","^3W","~$p"]]],"^29",["^10",[["~$f","~$p"],["~$f","^3W","~$p"]]],"^2@",["^10",[null,null]]]],"^I","~$promesa.core/error","^2=",false,"^6","promesa/core.cljc","^:",12,"^2<",["^ ","^2=",false,"^2>",3,"^2?",["^10",[["~$f","~$p"],["~$f","^3W","~$p"]]],"^29",["^10",[["~$f","~$p"],["~$f","^3W","~$p"]]],"^2@",["^10",[null,null]]],"^2?",["^10",[["~$f","~$p"],["~$f","^3W","~$p"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",168,"^9",168,"^2>",3,"^2C",true,"^29",["^10",[["~$f","~$p"],["~$f","^3W","~$p"]]],"^2;","Same as `catch` but with parameters inverted."],"~$pending?",["^ ","^28",null,"^5",["^ ","^6","promesa/core.cljc","^7",91,"^8",7,"^9",91,"^:",15,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Returns true if promise `p` is stil pending."],"^I","~$promesa.core/pending?","^2=",false,"^6","promesa/core.cljc","^:",15,"^2?",["^10",[["~$p"]]],"^2B",null,"^2@",["^10",[null,null]],"^8",1,"^7",91,"^9",91,"^2>",1,"^2C",true,"^29",["^10",["^2:",["^10",[["~$p"]]]]],"^2;","Returns true if promise `p` is stil pending."]],"^Z",["^ ","^U","^U"],"~:cljs.analyzer/constants",["^ ","^W",["^B",["~:else"]],"~:order",["^40"]],"^15",["^ ","^X",["^B",[]]],"^16",["^ "],"^17",["^V","^U","^O","^Q","^S"]],"^L","^J","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1E",[["^44","~:static-fns"],true,["^44","~:elide-asserts"],false,["^44","~:optimize-constants"],null,["^44","~:external-config"],null,["^44","~:tooling-config"],null,["^44","~:emit-constants"],null,["^44","~:infer-externs"],true,["^44","^1>"],null,["~:js-options","~:js-provider"],"^X",["~:mode"],"~:dev",["^44","~:fn-invoke-direct"],null,["^44","~:source-map"],"/dev/null"]]]