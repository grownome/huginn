["^ ","~:output",["^ ","~:js","goog.provide('clojure.test.check');\ngoog.require('cljs.core');\ngoog.require('clojure.test.check.generators');\ngoog.require('clojure.test.check.random');\ngoog.require('clojure.test.check.results');\ngoog.require('clojure.test.check.rose_tree');\ngoog.require('clojure.test.check.impl');\n\nclojure.test.check.make_rng = (function clojure$test$check$make_rng(seed){\nif(cljs.core.truth_(seed)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [seed,clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1(seed)], null);\n} else {\nvar non_nil_seed = clojure.test.check.impl.get_current_time_millis();\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [non_nil_seed,clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1(non_nil_seed)], null);\n}\n});\nclojure.test.check.complete = (function clojure$test$check$complete(property,num_trials,seed,reporter_fn){\nvar G__28505_28540 = new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"complete\",\"complete\",-500388775),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),property,new cljs.core.Keyword(null,\"result\",\"result\",1415092211),true,new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),num_trials,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),seed], null);\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__28505_28540) : reporter_fn.call(null,G__28505_28540));\n\nreturn new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"result\",\"result\",1415092211),true,new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),num_trials,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),seed], null);\n});\n/**\n * Tests `property` `num-tests` times.\n * \n *   Takes several optional keys:\n * \n *   `:seed`\n *  Can be used to re-run previous tests, as the seed used is returned\n *  after a test is run.\n * \n *   `:max-size`.\n *  can be used to control the 'size' of generated values. The size will\n *  start at 0, and grow up to max-size, as the number of tests increases.\n *  Generators will use the size parameter to bound their growth. This\n *  prevents, for example, generating a five-thousand element vector on\n *  the very first test.\n * \n *   `:reporter-fn`\n *  A callback function that will be called at various points in the test\n *  run, with a map like:\n * \n *    ;; called after a passing trial\n *    {:type      :trial\n *     :property  #<...>\n *     :so-far    <number of tests run so far>\n *     :num-tests <total number of tests>}\n * \n *    ;; called after each failing trial\n *    {:type         :failure\n *     :property     #<...>\n *     :result       ...\n *     :trial-number <tests ran before failure found>\n *     :failing-args [...]}\n * \n *  It will also be called on :complete, :shrink-step and :shrunk.\n * \n *   Examples:\n * \n *    (def p (for-all [a gen/pos-int] (> (* a a) a)))\n * \n *    (quick-check 100 p)\n *    (quick-check 200 p\n *                 :seed 42\n *                 :max-size 50\n *                 :reporter-fn (fn [m]\n *                                (when (= :failure (:type m))\n *                                  (println \"Uh oh...\"))))\n */\nclojure.test.check.quick_check = (function clojure$test$check$quick_check(var_args){\nvar args__4534__auto__ = [];\nvar len__4531__auto___28542 = arguments.length;\nvar i__4532__auto___28543 = (0);\nwhile(true){\nif((i__4532__auto___28543 < len__4531__auto___28542)){\nargs__4534__auto__.push((arguments[i__4532__auto___28543]));\n\nvar G__28544 = (i__4532__auto___28543 + (1));\ni__4532__auto___28543 = G__28544;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4535__auto__ = ((((2) < args__4534__auto__.length))?(new cljs.core.IndexedSeq(args__4534__auto__.slice((2)),(0),null)):null);\nreturn clojure.test.check.quick_check.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4535__auto__);\n});\n\nclojure.test.check.quick_check.cljs$core$IFn$_invoke$arity$variadic = (function (num_tests,property,p__28509){\nvar map__28510 = p__28509;\nvar map__28510__$1 = ((((!((map__28510 == null)))?(((((map__28510.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__28510.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__28510):map__28510);\nvar seed = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__28510__$1,new cljs.core.Keyword(null,\"seed\",\"seed\",68613327));\nvar max_size = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__28510__$1,new cljs.core.Keyword(null,\"max-size\",\"max-size\",-874966132),(200));\nvar reporter_fn = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__28510__$1,new cljs.core.Keyword(null,\"reporter-fn\",\"reporter-fn\",1280520247),cljs.core.constantly(null));\nvar vec__28512 = clojure.test.check.make_rng(seed);\nvar created_seed = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__28512,(0),null);\nvar rng = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__28512,(1),null);\nvar size_seq = clojure.test.check.generators.make_size_range_seq(max_size);\nvar so_far = (0);\nvar size_seq__$1 = size_seq;\nvar rstate = rng;\nwhile(true){\nif((so_far === num_tests)){\nreturn clojure.test.check.complete(property,num_tests,created_seed,reporter_fn);\n} else {\nvar vec__28516 = size_seq__$1;\nvar seq__28517 = cljs.core.seq(vec__28516);\nvar first__28518 = cljs.core.first(seq__28517);\nvar seq__28517__$1 = cljs.core.next(seq__28517);\nvar size = first__28518;\nvar rest_size_seq = seq__28517__$1;\nvar vec__28519 = clojure.test.check.random.split(rstate);\nvar r1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__28519,(0),null);\nvar r2 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__28519,(1),null);\nvar result_map_rose = clojure.test.check.generators.call_gen(property,r1,size);\nvar result_map = clojure.test.check.rose_tree.root(result_map_rose);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(result_map);\nvar args = new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(result_map);\nvar so_far__$1 = (so_far + (1));\nif(cljs.core.truth_(clojure.test.check.results.passing_QMARK_(result))){\nvar G__28522_28545 = new cljs.core.PersistentArrayMap(null, 4, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"trial\",\"trial\",-677458347),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),property,new cljs.core.Keyword(null,\"so-far\",\"so-far\",-1973642241),so_far__$1,new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),num_tests], null);\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__28522_28545) : reporter_fn.call(null,G__28522_28545));\n\nvar G__28547 = so_far__$1;\nvar G__28548 = rest_size_seq;\nvar G__28549 = r2;\nso_far = G__28547;\nsize_seq__$1 = G__28548;\nrstate = G__28549;\ncontinue;\n} else {\nreturn (clojure.test.check.failure.cljs$core$IFn$_invoke$arity$6 ? clojure.test.check.failure.cljs$core$IFn$_invoke$arity$6(property,result_map_rose,so_far__$1,size,created_seed,reporter_fn) : clojure.test.check.failure.call(null,property,result_map_rose,so_far__$1,size,created_seed,reporter_fn));\n}\n}\nbreak;\n}\n});\n\nclojure.test.check.quick_check.cljs$lang$maxFixedArity = (2);\n\n/** @this {Function} */\nclojure.test.check.quick_check.cljs$lang$applyTo = (function (seq28506){\nvar G__28507 = cljs.core.first(seq28506);\nvar seq28506__$1 = cljs.core.next(seq28506);\nvar G__28508 = cljs.core.first(seq28506__$1);\nvar seq28506__$2 = cljs.core.next(seq28506__$1);\nvar self__4518__auto__ = this;\nreturn self__4518__auto__.cljs$core$IFn$_invoke$arity$variadic(G__28507,G__28508,seq28506__$2);\n});\n\nclojure.test.check.smallest_shrink = (function clojure$test$check$smallest_shrink(total_nodes_visited,depth,smallest){\nvar map__28523 = smallest;\nvar map__28523__$1 = ((((!((map__28523 == null)))?(((((map__28523.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__28523.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__28523):map__28523);\nvar result = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__28523__$1,new cljs.core.Keyword(null,\"result\",\"result\",1415092211));\nreturn new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"total-nodes-visited\",\"total-nodes-visited\",-620132443),total_nodes_visited,new cljs.core.Keyword(null,\"depth\",\"depth\",1768663640),depth,new cljs.core.Keyword(null,\"result\",\"result\",1415092211),clojure.test.check.results.passing_QMARK_(result),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),clojure.test.check.results.result_data(result),new cljs.core.Keyword(null,\"smallest\",\"smallest\",-152623883),new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(smallest)], null);\n});\n/**\n * Shrinking a value produces a sequence of smaller values of the same type.\n *   Each of these values can then be shrunk. Think of this as a tree. We do a\n *   modified depth-first search of the tree:\n * \n *   Do a non-exhaustive search for a deeper (than the root) failing example.\n *   Additional rules added to depth-first search:\n *   * If a node passes the property, you may continue searching at this depth,\n *   but not backtrack\n *   * If a node fails the property, search its children\n *   The value returned is the left-most failing example at the depth where a\n *   passing example was found.\n * \n *   Calls reporter-fn on every shrink step.\n */\nclojure.test.check.shrink_loop = (function clojure$test$check$shrink_loop(rose_tree,reporter_fn){\nvar shrinks_this_depth = clojure.test.check.rose_tree.children(rose_tree);\nvar nodes = shrinks_this_depth;\nvar current_smallest = clojure.test.check.rose_tree.root(rose_tree);\nvar total_nodes_visited = (0);\nvar depth = (0);\nwhile(true){\nif(cljs.core.empty_QMARK_(nodes)){\nreturn clojure.test.check.smallest_shrink(total_nodes_visited,depth,current_smallest);\n} else {\nvar head = cljs.core.first(nodes);\nvar tail = cljs.core.rest(nodes);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(clojure.test.check.rose_tree.root(head));\nvar args = new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(clojure.test.check.rose_tree.root(head));\nvar shrink_step_map = new cljs.core.PersistentArrayMap(null, 3, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"shrink-step\",\"shrink-step\",-541828120),new cljs.core.Keyword(null,\"result\",\"result\",1415092211),result,new cljs.core.Keyword(null,\"args\",\"args\",1315556576),args], null);\nif(cljs.core.truth_(clojure.test.check.results.passing_QMARK_(result))){\nvar G__28532_28551 = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([shrink_step_map,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),true,new cljs.core.Keyword(null,\"current-smallest\",\"current-smallest\",1840631643),current_smallest], null)], 0));\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__28532_28551) : reporter_fn.call(null,G__28532_28551));\n\nvar G__28552 = tail;\nvar G__28553 = current_smallest;\nvar G__28554 = (total_nodes_visited + (1));\nvar G__28555 = depth;\nnodes = G__28552;\ncurrent_smallest = G__28553;\ntotal_nodes_visited = G__28554;\ndepth = G__28555;\ncontinue;\n} else {\nvar new_smallest = clojure.test.check.rose_tree.root(head);\nvar G__28533_28556 = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([shrink_step_map,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"pass?\",\"pass?\",-424635753),false,new cljs.core.Keyword(null,\"current-smallest\",\"current-smallest\",1840631643),new_smallest], null)], 0));\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__28533_28556) : reporter_fn.call(null,G__28533_28556));\n\nvar temp__5455__auto__ = cljs.core.seq(clojure.test.check.rose_tree.children(head));\nif(temp__5455__auto__){\nvar children = temp__5455__auto__;\nvar G__28560 = children;\nvar G__28561 = new_smallest;\nvar G__28562 = (total_nodes_visited + (1));\nvar G__28563 = (depth + (1));\nnodes = G__28560;\ncurrent_smallest = G__28561;\ntotal_nodes_visited = G__28562;\ndepth = G__28563;\ncontinue;\n} else {\nvar G__28564 = tail;\nvar G__28565 = new_smallest;\nvar G__28566 = (total_nodes_visited + (1));\nvar G__28567 = depth;\nnodes = G__28564;\ncurrent_smallest = G__28565;\ntotal_nodes_visited = G__28566;\ndepth = G__28567;\ncontinue;\n}\n}\n}\nbreak;\n}\n});\nclojure.test.check.failure = (function clojure$test$check$failure(property,failing_rose_tree,trial_number,size,seed,reporter_fn){\nvar root = clojure.test.check.rose_tree.root(failing_rose_tree);\nvar result = new cljs.core.Keyword(null,\"result\",\"result\",1415092211).cljs$core$IFn$_invoke$arity$1(root);\nvar failing_args = new cljs.core.Keyword(null,\"args\",\"args\",1315556576).cljs$core$IFn$_invoke$arity$1(root);\nvar G__28536_28568 = new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"failure\",\"failure\",720415879),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),property,new cljs.core.Keyword(null,\"result\",\"result\",1415092211),clojure.test.check.results.passing_QMARK_(result),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),clojure.test.check.results.result_data(result),new cljs.core.Keyword(null,\"trial-number\",\"trial-number\",1762056689),trial_number,new cljs.core.Keyword(null,\"failing-args\",\"failing-args\",-890623811),failing_args], null);\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__28536_28568) : reporter_fn.call(null,G__28536_28568));\n\nvar shrunk = clojure.test.check.shrink_loop(failing_rose_tree,((function (root,result,failing_args){\nreturn (function (p1__28535_SHARP_){\nvar G__28538 = cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(p1__28535_SHARP_,new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),property);\nreturn (reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__28538) : reporter_fn.call(null,G__28538));\n});})(root,result,failing_args))\n);\nvar G__28539_28569 = new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"type\",\"type\",1174270348),new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),new cljs.core.Keyword(null,\"property\",\"property\",-1114278232),property,new cljs.core.Keyword(null,\"trial-number\",\"trial-number\",1762056689),trial_number,new cljs.core.Keyword(null,\"failing-args\",\"failing-args\",-890623811),failing_args,new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),shrunk], null);\n(reporter_fn.cljs$core$IFn$_invoke$arity$1 ? reporter_fn.cljs$core$IFn$_invoke$arity$1(G__28539_28569) : reporter_fn.call(null,G__28539_28569));\n\nreturn new cljs.core.PersistentArrayMap(null, 7, [new cljs.core.Keyword(null,\"result\",\"result\",1415092211),clojure.test.check.results.passing_QMARK_(result),new cljs.core.Keyword(null,\"result-data\",\"result-data\",-1724248844),clojure.test.check.results.result_data(result),new cljs.core.Keyword(null,\"seed\",\"seed\",68613327),seed,new cljs.core.Keyword(null,\"failing-size\",\"failing-size\",-429562538),size,new cljs.core.Keyword(null,\"num-tests\",\"num-tests\",2050041354),trial_number,new cljs.core.Keyword(null,\"fail\",\"fail\",1706214930),cljs.core.vec(failing_args),new cljs.core.Keyword(null,\"shrunk\",\"shrunk\",-2041664412),shrunk], null);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/test/check.cljc","~:line",10,"~:column",5,"~:end-line",10,"~:end-column",23],"~:ns-aliases",["^ ","~$clojure.core.async","~$cljs.core.async","~$raspicam","~$shadow.js.shim.module$raspicam"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$clojure.test.check.results","^I","~$rose","~$clojure.test.check.rose-tree","~$results","^I","~$clojure.test.check.impl","^M","^K","^K","~$cljs.core","^N","~$clojure.test.check.generators","^O","~$goog","^P","~$gen","^O","~$clojure.test.check.random","^R","~$random","^R"],"~:seen",["^B",["~:require"]],"~:uses",["^ ","~$get-current-time-millis","^M","~$exception-like?","^M"],"~:require-macros",["^ ","^N","^N"],"~:form",["~#list",["~$ns","^D",["^[",["^U",["^O","~:as","^Q"],["^R","^11","^S"],["^I","^11","^L"],["^K","^11","^J"],["^M","~:refer",["^W","^X"]]]]]],"~:flags",["^ ","^U",["^B",[]]],"~:js-deps",["^ "],"~:deps",["^P","^N","^O","^R","^I","^K","^M"]],"^F","^D","~:resource-id",["~:shadow.build.classpath/resource","clojure/test/check.cljc"],"~:compiled-at",1540145000105,"~:resource-name","clojure/test/check.cljc","~:warnings",[],"~:source",";   Copyright (c) Rich Hickey, Reid Draper, and contributors.\n;   All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns clojure.test.check\n  (:require [clojure.test.check.generators :as gen]\n            [clojure.test.check.random :as random]\n            [clojure.test.check.results :as results]\n            [clojure.test.check.rose-tree :as rose]\n            [clojure.test.check.impl :refer [get-current-time-millis\n                                             exception-like?]]))\n\n(declare shrink-loop failure)\n\n(defn- make-rng\n  [seed]\n  (if seed\n    [seed (random/make-random seed)]\n    (let [non-nil-seed (get-current-time-millis)]\n      [non-nil-seed (random/make-random non-nil-seed)])))\n\n(defn- complete\n  [property num-trials seed reporter-fn]\n  (reporter-fn {:type :complete\n                :property property\n                :result true\n                :num-tests num-trials\n                :seed seed})\n\n  {:result true :num-tests num-trials :seed seed})\n\n(defn quick-check\n  \"Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type      :trial\n       :property  #<...>\n       :so-far    <number of tests run so far>\n       :num-tests <total number of tests>}\n\n      ;; called after each failing trial\n      {:type         :failure\n       :property     #<...>\n       :result       ...\n       :trial-number <tests ran before failure found>\n       :failing-args [...]}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \\\"Uh oh...\\\"))))\"\n  [num-tests property & {:keys [seed max-size reporter-fn]\n                         :or {max-size 200, reporter-fn (constantly nil)}}]\n  (let [[created-seed rng] (make-rng seed)\n        size-seq (gen/make-size-range-seq max-size)]\n    (loop [so-far 0\n           size-seq size-seq\n           rstate rng]\n      (if (== so-far num-tests)\n        (complete property num-tests created-seed reporter-fn)\n        (let [[size & rest-size-seq] size-seq\n              [r1 r2] (random/split rstate)\n              result-map-rose (gen/call-gen property r1 size)\n              result-map (rose/root result-map-rose)\n              result (:result result-map)\n              args (:args result-map)\n              so-far (inc so-far)]\n          (if (results/passing? result)\n            (do\n              (reporter-fn {:type :trial\n                            :property property\n                            :so-far so-far\n                            :num-tests num-tests})\n              (recur so-far rest-size-seq r2))\n            (failure property result-map-rose so-far size created-seed reporter-fn)))))))\n\n(defn- smallest-shrink\n  [total-nodes-visited depth smallest]\n  (let [{:keys [result]} smallest]\n    {:total-nodes-visited total-nodes-visited\n     :depth depth\n     :result (results/passing? result)\n     :result-data (results/result-data result)\n     :smallest (:args smallest)}))\n\n(defn- shrink-loop\n  \"Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step.\"\n  [rose-tree reporter-fn]\n  (let [shrinks-this-depth (rose/children rose-tree)]\n    (loop [nodes shrinks-this-depth\n           current-smallest (rose/root rose-tree)\n           total-nodes-visited 0\n           depth 0]\n      (if (empty? nodes)\n        (smallest-shrink total-nodes-visited depth current-smallest)\n        (let [;; can't destructure here because that could force\n              ;; evaluation of (second nodes)\n              head (first nodes)\n              tail (rest nodes)\n              result (:result (rose/root head))\n              args (:args (rose/root head))\n              shrink-step-map {:type :shrink-step\n                               :result result\n                               :args args}]\n          (if (results/passing? result)\n            ;; this node passed the test, so now try testing its right-siblings\n            (do\n              (reporter-fn (merge shrink-step-map {:pass? true\n                                                   :current-smallest current-smallest}))\n              (recur tail current-smallest (inc total-nodes-visited) depth))\n            ;; this node failed the test, so check if it has children,\n            ;; if so, traverse down them. If not, save this as the best example\n            ;; seen now and then look at the right-siblings\n            ;; children\n            (let [new-smallest (rose/root head)]\n              (reporter-fn (merge shrink-step-map {:pass? false\n                                                   :current-smallest new-smallest}))\n              (if-let [children (seq (rose/children head))]\n                (recur children new-smallest (inc total-nodes-visited) (inc depth))\n                (recur tail new-smallest (inc total-nodes-visited) depth)))))))))\n\n(defn- failure\n  [property failing-rose-tree trial-number size seed reporter-fn]\n  (let [root (rose/root failing-rose-tree)\n        result (:result root)\n        failing-args (:args root)]\n\n    (reporter-fn {:type :failure\n                  :property property\n                  :result (results/passing? result)\n                  :result-data (results/result-data result)\n                  :trial-number trial-number\n                  :failing-args failing-args})\n\n    (let [shrunk (shrink-loop failing-rose-tree\n                              #(reporter-fn (assoc % :property property)))]\n      (reporter-fn {:type :shrunk\n                    :property property\n                    :trial-number trial-number\n                    :failing-args failing-args\n                    :shrunk shrunk})\n      {:result (results/passing? result)\n       :result-data (results/result-data result)\n       :seed seed\n       :failing-size size\n       :num-tests trial-number\n       :fail (vec failing-args)\n       :shrunk shrunk})))\n","~:reader-features",["^B",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings","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","names",["clojure.test.check/make-rng","seed","clojure.test.check.random.make_random.cljs$core$IFn$_invoke$arity$1","non-nil-seed","clojure.test.check.impl/get-current-time-millis","clojure.test.check/complete","property","num-trials","reporter-fn","G__28505","var_args","args__4534__auto__","len__4531__auto__","i__4532__auto__","argseq__4535__auto__","cljs.core/IndexedSeq","clojure.test.check/quick-check","p__28509","map__28510","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","cljs.core.get.cljs$core$IFn$_invoke$arity$3","seq28506","G__28507","cljs.core/first","cljs.core/next","G__28508","self__4518__auto__","num-tests","max-size","cljs.core/constantly","vec__28512","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","created-seed","rng","size-seq","clojure.test.check.generators/make-size-range-seq","so-far","rstate","vec__28516","seq__28517","cljs.core/seq","first__28518","vec__28519","size","rest-size-seq","r1","r2","clojure.test.check.random/split","result-map-rose","clojure.test.check.generators/call-gen","result-map","clojure.test.check.rose-tree/root","result","args","clojure.test.check.results/passing?","G__28522","clojure.test.check/failure","clojure.test.check/smallest-shrink","total-nodes-visited","depth","smallest","map__28523","clojure.test.check.results/result-data","clojure.test.check/shrink-loop","rose-tree","shrinks-this-depth","clojure.test.check.rose-tree/children","nodes","current-smallest","cljs.core/empty?","head","tail","cljs.core/rest","shrink-step-map","G__28532","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","new-smallest","G__28533","temp__5455__auto__","children","failing-rose-tree","trial-number","root","failing-args","G__28536","shrunk","p1__28535#","G__28538","cljs.core.assoc.cljs$core$IFn$_invoke$arity$3","G__28539","cljs.core/vec"]]],"~:cache-keys",["~#cmap",[["~:macro","^N"],[1534380137000],["^17","goog/math/math.js"],[1530991559994,"^P","~$goog.array","~$goog.asserts"],["^17","goog/array/array.js"],[1530991559994,"^P","^1F"],["^17","clojure/test/check/generators.cljc"],[1535586405418,"^P","^N","^R","^K","~$goog.string","~$clojure.string"],["^17","goog/debug/error.js"],[1530991559994,"^P"],["^17","clojure/test/check/random/doubles.cljs"],[1535586405418,"^P","^N","~$clojure.test.check.random.longs"],["^17","goog/dom/nodetype.js"],[1530991559994,"^P"],["^17","clojure/test/check/rose_tree.cljc"],[1535586405418,"^P","^N"],["^17","clojure/test/check/impl.cljc"],[1535586405418,"^P","^N"],["^17","clojure/test/check/random.cljs"],[1535586405418,"^P","^N","~$clojure.test.check.random.doubles","^1I"],["^17","goog/object/object.js"],[1530991559994,"^P"],"~:SHADOW-TIMESTAMP",[1540077702000,1534380137000],["^17","goog/math/long.js"],[1530991559994,"^P","^1F","~$goog.reflect"],["^17","clojure/test/check.cljc"],[1535586405418,"^P","^N","^O","^R","^I","^K","^M"],["^17","goog/functions/functions.js"],[1530991559994,"^P"],["^17","goog/structs/map.js"],[1530991559994,"^P","~$goog.iter.Iterator","~$goog.iter.StopIteration","~$goog.object"],["^17","goog/asserts/asserts.js"],[1530991559994,"^P","~$goog.debug.Error","~$goog.dom.NodeType","^1G"],["^17","goog/uri/uri.js"],[1530991559994,"^P","^1E","^1F","^1G","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"],["^17","goog/base.js"],[1530991559994],["^17","goog/structs/structs.js"],[1530991559994,"^P","^1E","^1O"],["^17","clojure/string.cljs"],[1534380137690,"^P","^N","^1G","~$goog.string.StringBuffer"],["^17","clojure/test/check/random/longs/bit_count_impl.cljs"],[1535586405418,"^P","^N"],["^17","goog/string/string.js"],[1530991559994,"^P"],["^17","goog/reflect/reflect.js"],[1530991559994,"^P"],["^17","goog/string/stringbuffer.js"],[1530991559994,"^P"],["^17","goog/iter/iter.js"],[1530991559994,"^P","^1E","^1F","~$goog.functions","~$goog.math"],["^17","cljs/core.cljs"],[1534380137690,"~$goog.math.Long","~$goog.math.Integer","^1G","^1O","^1E","~$goog.Uri","^1W"],["^17","clojure/test/check/random/longs.cljs"],[1535586405418,"^P","^N","~$clojure.test.check.random.longs.bit-count-impl","^1Z"],["^17","goog/math/integer.js"],[1530991559994,"^P"],["^17","goog/uri/utils.js"],[1530991559994,"^P","^1E","^1F","^1G"],["^17","clojure/test/check/results.cljc"],[1535586405418,"^P","^N"]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/test/check.cljc","^7",10,"^8",5,"^9",10,"^:",23],"^;",["^ ","^<","^=","^>","^?"],"^@",null,"^A",["^B",[]],"^C","^D","^G",null,"^H",["^ ","^I","^I","^J","^K","^L","^I","^M","^M","^K","^K","^N","^N","^O","^O","^P","^P","^Q","^O","^R","^R","^S","^R"],"^T",["^B",["^U"]],"^V",["^ ","^W","^M","^X","^M"],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",117,"^8",8,"^9",117,"^:",19,"~:private",true,"~:arglists",["^[",["~$quote",["^[",[["~$rose-tree","~$reporter-fn"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"^26",true,"^C","~$clojure.test.check/shrink-loop","~:variadic",false,"^6","clojure/test/check.cljc","^:",19,"~:method-params",["^[",[["^29","^2:"]]],"~:protocol-impl",null,"~:arglists-meta",["^[",[null,null]],"^8",1,"^7",117,"^9",117,"~:max-fixed-arity",2,"~:fn-var",true,"^27",["^[",["^28",["^[",[["^29","^2:"]]]]],"^2;","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found.\n\n  Calls reporter-fn on every shrink step."],"~$failure",["^ ","^25",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",165,"^8",8,"^9",165,"^:",15,"^26",true,"^27",["^[",["^28",["^[",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed","^2:"]]]]]],"^26",true,"^C","~$clojure.test.check/failure","^2=",false,"^6","clojure/test/check.cljc","^:",15,"^2>",["^[",[["^2D","^2E","^2F","^2G","^2H","^2:"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^7",165,"^9",165,"^2A",6,"^2B",true,"^27",["^[",["^28",["^[",[["^2D","^2E","^2F","^2G","^2H","^2:"]]]]]],"~$make-rng",["^ ","^25",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",20,"^8",8,"^9",20,"^:",16,"^26",true,"^27",["^[",["^28",["^[",[["^2H"]]]]]],"^26",true,"^C","~$clojure.test.check/make-rng","^2=",false,"^6","clojure/test/check.cljc","^:",16,"^2>",["^[",[["^2H"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^7",20,"^9",20,"^2A",1,"^2B",true,"^27",["^[",["^28",["^[",[["^2H"]]]]]],"~$complete",["^ ","^25",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",27,"^8",8,"^9",27,"^:",16,"^26",true,"^27",["^[",["^28",["^[",[["^2D","~$num-trials","^2H","^2:"]]]]]],"^26",true,"^C","~$clojure.test.check/complete","^2=",false,"^6","clojure/test/check.cljc","^:",16,"^2>",["^[",[["^2D","^2M","^2H","^2:"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^7",27,"^9",27,"^2A",4,"^2B",true,"^27",["^[",["^28",["^[",[["^2D","^2M","^2H","^2:"]]]]]],"~$quick-check",["^ ","^25",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",37,"^8",7,"^9",37,"^:",18,"^27",["^[",["^28",["^[",[["~$num-tests","^2D","~$&",["^ ","~:keys",["^2H","~$max-size","^2:"],"~:or",["^ ","^2R",200,"^2:",["^[",["~$constantly",null]]]]]]]]],"^2;","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type      :trial\n       :property  #<...>\n       :so-far    <number of tests run so far>\n       :num-tests <total number of tests>}\n\n      ;; called after each failing trial\n      {:type         :failure\n       :property     #<...>\n       :result       ...\n       :trial-number <tests ran before failure found>\n       :failing-args [...]}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))","~:top-fn",["^ ","^2=",true,"^2A",2,"^2>",[["^[",["^2P","^2D",["^ ","^2Q",["^2H","^2R","^2:"],"^2S",["^ ","^2R",200,"^2:",["^[",["^2T",null]]]]]]],"^27",["^[",[["^2P","^2D","~$&",["^ ","^2Q",["^2H","^2R","^2:"],"^2S",["^ ","^2R",200,"^2:",["^[",["^2T",null]]]]]]],"^2@",["^[",[null]]]],"^C","~$clojure.test.check/quick-check","^2=",true,"^6","clojure/test/check.cljc","^:",18,"^2U",["^ ","^2=",true,"^2A",2,"^2>",[["^[",["^2P","^2D",["^ ","^2Q",["^2H","^2R","^2:"],"^2S",["^ ","^2R",200,"^2:",["^[",["^2T",null]]]]]]],"^27",["^[",[["^2P","^2D","~$&",["^ ","^2Q",["^2H","^2R","^2:"],"^2S",["^ ","^2R",200,"^2:",["^[",["^2T",null]]]]]]],"^2@",["^[",[null]]],"^2>",[["^[",["^2P","^2D",["^ ","^2Q",["^2H","^2R","^2:"],"^2S",["^ ","^2R",200,"^2:",["^[",["^2T",null]]]]]]],"^2?",null,"^2@",["^[",[null]],"^8",1,"^7",37,"^9",37,"^2A",2,"^2B",true,"^27",["^[",[["^2P","^2D","~$&",["^ ","^2Q",["^2H","^2R","^2:"],"^2S",["^ ","^2R",200,"^2:",["^[",["^2T",null]]]]]]],"^2;","Tests `property` `num-tests` times.\n\n  Takes several optional keys:\n\n  `:seed`\n    Can be used to re-run previous tests, as the seed used is returned\n    after a test is run.\n\n  `:max-size`.\n    can be used to control the 'size' of generated values. The size will\n    start at 0, and grow up to max-size, as the number of tests increases.\n    Generators will use the size parameter to bound their growth. This\n    prevents, for example, generating a five-thousand element vector on\n    the very first test.\n\n  `:reporter-fn`\n    A callback function that will be called at various points in the test\n    run, with a map like:\n\n      ;; called after a passing trial\n      {:type      :trial\n       :property  #<...>\n       :so-far    <number of tests run so far>\n       :num-tests <total number of tests>}\n\n      ;; called after each failing trial\n      {:type         :failure\n       :property     #<...>\n       :result       ...\n       :trial-number <tests ran before failure found>\n       :failing-args [...]}\n\n    It will also be called on :complete, :shrink-step and :shrunk.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n\n      (quick-check 100 p)\n      (quick-check 200 p\n                   :seed 42\n                   :max-size 50\n                   :reporter-fn (fn [m]\n                                  (when (= :failure (:type m))\n                                    (println \"Uh oh...\"))))"],"~$smallest-shrink",["^ ","^25",null,"^5",["^ ","^6","clojure/test/check.cljc","^7",108,"^8",8,"^9",108,"^:",23,"^26",true,"^27",["^[",["^28",["^[",[["~$total-nodes-visited","~$depth","~$smallest"]]]]]],"^26",true,"^C","~$clojure.test.check/smallest-shrink","^2=",false,"^6","clojure/test/check.cljc","^:",23,"^2>",["^[",[["^2X","^2Y","^2Z"]]],"^2?",null,"^2@",["^[",[null,null]],"^8",1,"^7",108,"^9",108,"^2A",3,"^2B",true,"^27",["^[",["^28",["^[",[["^2X","^2Y","^2Z"]]]]]]],"^Y",["^ ","^N","^N"],"~:cljs.analyzer/constants",["^ ","^T",["^B",["~:args","~:shrunk","~:total-nodes-visited","~:failure","~:property","~:shrink-step","~:num-tests","~:type","~:max-size","~:seed","~:trial-number","~:fail","~:result","~:result-data","~:smallest","~:trial","~:failing-size","~:reporter-fn","~:pass?","~:depth","~:complete","~:current-smallest","~:failing-args","~:so-far"]],"~:order",["^38","^35","^3=","^37","^3:","^3E","^39","^3B","^31","^3H","^3@","^33","^3D","^3>","^3?","^36","^3C","^3F","^3;","^3G","^34","^32","^3A","^3<"]],"^13",["^ ","^U",["^B",[]]],"^14",["^ "],"^15",["^P","^N","^O","^R","^I","^K","^M"]],"^F","^D","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^1C",[["^3L","~:static-fns"],true,["^3L","~:elide-asserts"],false,["^3L","~:optimize-constants"],null,["^3L","~:external-config"],null,["^3L","~:tooling-config"],null,["^3L","~:emit-constants"],null,["^3L","~:infer-externs"],true,["^3L","^1<"],null,["~:js-options","~:js-provider"],"^U",["~:mode"],"~:dev",["^3L","~:fn-invoke-direct"],null,["^3L","~:source-map"],"/dev/null"]]]