["^ ","~:output",["^ ","~:js","goog.provide('clojure.walk');\ngoog.require('cljs.core');\n/**\n * Traverses form, an arbitrary data structure.  inner and outer are\n *   functions.  Applies inner to each element of form, building up a\n *   data structure of the same type, then applies outer to the result.\n *   Recognizes all Clojure data structures. Consumes seqs as with doall.\n */\nclojure.walk.walk = (function clojure$walk$walk(inner,outer,form){\nif(cljs.core.list_QMARK_(form)){\nvar G__11840 = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.list,cljs.core.map.cljs$core$IFn$_invoke$arity$2(inner,form));\nreturn (outer.cljs$core$IFn$_invoke$arity$1 ? outer.cljs$core$IFn$_invoke$arity$1(G__11840) : outer.call(null,G__11840));\n} else {\nif(cljs.core.map_entry_QMARK_(form)){\nvar G__11841 = cljs.core.vec(cljs.core.map.cljs$core$IFn$_invoke$arity$2(inner,form));\nreturn (outer.cljs$core$IFn$_invoke$arity$1 ? outer.cljs$core$IFn$_invoke$arity$1(G__11841) : outer.call(null,G__11841));\n} else {\nif(cljs.core.seq_QMARK_(form)){\nvar G__11842 = cljs.core.doall.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(inner,form));\nreturn (outer.cljs$core$IFn$_invoke$arity$1 ? outer.cljs$core$IFn$_invoke$arity$1(G__11842) : outer.call(null,G__11842));\n} else {\nif(cljs.core.record_QMARK_(form)){\nvar G__11843 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (r,x){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(r,(inner.cljs$core$IFn$_invoke$arity$1 ? inner.cljs$core$IFn$_invoke$arity$1(x) : inner.call(null,x)));\n}),form,form);\nreturn (outer.cljs$core$IFn$_invoke$arity$1 ? outer.cljs$core$IFn$_invoke$arity$1(G__11843) : outer.call(null,G__11843));\n} else {\nif(cljs.core.coll_QMARK_(form)){\nvar G__11844 = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.empty(form),cljs.core.map.cljs$core$IFn$_invoke$arity$2(inner,form));\nreturn (outer.cljs$core$IFn$_invoke$arity$1 ? outer.cljs$core$IFn$_invoke$arity$1(G__11844) : outer.call(null,G__11844));\n} else {\nreturn (outer.cljs$core$IFn$_invoke$arity$1 ? outer.cljs$core$IFn$_invoke$arity$1(form) : outer.call(null,form));\n\n}\n}\n}\n}\n}\n});\n/**\n * Performs a depth-first, post-order traversal of form.  Calls f on\n *   each sub-form, uses f's return value in place of the original.\n *   Recognizes all Clojure data structures. Consumes seqs as with doall.\n */\nclojure.walk.postwalk = (function clojure$walk$postwalk(f,form){\nreturn clojure.walk.walk(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(clojure.walk.postwalk,f),f,form);\n});\n/**\n * Like postwalk, but does pre-order traversal.\n */\nclojure.walk.prewalk = (function clojure$walk$prewalk(f,form){\nreturn clojure.walk.walk(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(clojure.walk.prewalk,f),cljs.core.identity,(f.cljs$core$IFn$_invoke$arity$1 ? f.cljs$core$IFn$_invoke$arity$1(form) : f.call(null,form)));\n});\n/**\n * Recursively transforms all map keys from strings to keywords.\n */\nclojure.walk.keywordize_keys = (function clojure$walk$keywordize_keys(m){\nvar f = (function (p__11845){\nvar vec__11846 = p__11845;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11846,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11846,(1),null);\nif(typeof k === 'string'){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.keyword.cljs$core$IFn$_invoke$arity$1(k),v], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null);\n}\n});\nreturn clojure.walk.postwalk(((function (f){\nreturn (function (x){\nif(cljs.core.map_QMARK_(x)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,x));\n} else {\nreturn x;\n}\n});})(f))\n,m);\n});\n/**\n * Recursively transforms all map keys from keywords to strings.\n */\nclojure.walk.stringify_keys = (function clojure$walk$stringify_keys(m){\nvar f = (function (p__11849){\nvar vec__11850 = p__11849;\nvar k = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11850,(0),null);\nvar v = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__11850,(1),null);\nif((k instanceof cljs.core.Keyword)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.name(k),v], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [k,v], null);\n}\n});\nreturn clojure.walk.postwalk(((function (f){\nreturn (function (x){\nif(cljs.core.map_QMARK_(x)){\nreturn cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentArrayMap.EMPTY,cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,x));\n} else {\nreturn x;\n}\n});})(f))\n,m);\n});\n/**\n * Recursively transforms form by replacing keys in smap with their\n *   values.  Like clojure/replace but works on any data structure.  Does\n *   replacement at the root of the tree first.\n */\nclojure.walk.prewalk_replace = (function clojure$walk$prewalk_replace(smap,form){\nreturn clojure.walk.prewalk((function (x){\nif(cljs.core.contains_QMARK_(smap,x)){\nreturn (smap.cljs$core$IFn$_invoke$arity$1 ? smap.cljs$core$IFn$_invoke$arity$1(x) : smap.call(null,x));\n} else {\nreturn x;\n}\n}),form);\n});\n/**\n * Recursively transforms form by replacing keys in smap with their\n *   values.  Like clojure/replace but works on any data structure.  Does\n *   replacement at the leaves of the tree first.\n */\nclojure.walk.postwalk_replace = (function clojure$walk$postwalk_replace(smap,form){\nreturn clojure.walk.postwalk((function (x){\nif(cljs.core.contains_QMARK_(smap,x)){\nreturn (smap.cljs$core$IFn$_invoke$arity$1 ? smap.cljs$core$IFn$_invoke$arity$1(x) : smap.call(null,x));\n} else {\nreturn x;\n}\n}),form);\n});\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","clojure/walk.cljs","~:line",35,"~:column",3,"~:end-line",35,"~:end-column",15,"~:author","Stuart Sierra","~:doc","This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function."],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$clojure.walk","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$cljs.core","^F","~$goog","^G"],"~:seen",["^?",[]],"~:uses",null,"~:require-macros",["^ ","^F","^F"],"~:form",["~#list",["~$ns","^A"]],"~:flags",["^ "],"~:js-deps",["^ "],"~:deps",["^G","^F"]],"^C","^A","~:resource-id",["~:shadow.build.classpath/resource","clojure/walk.cljs"],"~:compiled-at",1538608797272,"~:resource-name","clojure/walk.cljs","~:warnings",[],"~:source",";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n;;; walk.cljs - generic tree walker with replacement\n\n;; by Stuart Sierra\n;; Jul5 17, 2011\n\n;; CHANGE LOG:\n;;\n;; * July 17, 2011: Port to ClojureScript\n;; \n;; * December 15, 2008: replaced 'walk' with 'prewalk' & 'postwalk'\n;;\n;; * December 9, 2008: first version\n\n\n(ns \n  ^{:author \"Stuart Sierra\",\n     :doc \"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\\"walk\\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.\"}\n  clojure.walk)\n\n(defn walk\n  \"Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n\n  {:added \"1.1\"}\n  [inner outer form]\n  (cond\n    (list? form)      (outer (apply list (map inner form)))\n    (map-entry? form) (outer (vec (map inner form)))\n    (seq? form)       (outer (doall (map inner form)))\n    (record? form)    (outer (reduce (fn [r x] (conj r (inner x))) form form))\n    (coll? form)      (outer (into (empty form) (map inner form)))\n    :else             (outer form)))\n\n(defn postwalk\n  \"Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial postwalk f) f form))\n\n(defn prewalk\n  \"Like postwalk, but does pre-order traversal.\"\n  {:added \"1.1\"}\n  [f form]\n  (walk (partial prewalk f) identity (f form)))\n\n(defn keywordize-keys\n  \"Recursively transforms all map keys from strings to keywords.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn stringify-keys\n  \"Recursively transforms all map keys from keywords to strings.\"\n  {:added \"1.1\"}\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))\n\n(defn prewalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n\n(defn postwalk-replace\n  \"Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.\"\n  {:added \"1.1\"}\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))\n","~:reader-features",["^?",["~:cljs"]],"~:source-map",["^ ","~i36",["^ ","~i0",[["^ ","~:gcol",0,"~:gline",2],["^ ","^[",20,"^10",8],["^ ","^[",0,"^10",9]],"~i6",[["^ ","^[",0,"^10",8,"^@","clojure.walk/walk"]]],"~i43",["^ ","~i3",[["^ ","^[",48,"^10",8,"^@","inner"]],"~i9",[["^ ","^[",54,"^10",8,"^@","outer"]],"~i15",[["^ ","^[",60,"^10",8,"^@","form"]]],"~i44",["^ ","~i2",[["^ ","^[",0,"^10",9],["^ ","^[",0,"^10",13],["^ ","^[",0,"^10",17],["^ ","^[",0,"^10",21],["^ ","^[",0,"^10",27],["^ ","^[",0,"^10",31]]],"~i45",["^ ","~i4",[["^ ","^[",3,"^10",9]],"~i5",[["^ ","^[",3,"^10",9,"^@","cljs.core/list?"]],"~i11",[["^ ","^[",25,"^10",9,"^@","form"]],"~i22",[["^ ","^[",0,"^10",10],["^ ","^[",4,"^10",10,"^@","G__11840"],["^ ","^[",0,"^10",11],["^ ","^[",0,"^10",11],["^ ","^[",82,"^10",11,"^@","G__11840"],["^ ","^[",110,"^10",11,"^@","G__11840"]],"~i23",[["^ ","^[",8,"^10",11,"^@","outer"],["^ ","^[",46,"^10",11,"^@","outer"],["^ ","^[",94,"^10",11,"^@","outer"]],"~i29",[["^ ","^[",15,"^10",10]],"~i30",[["^ ","^[",15,"^10",10,"^@","cljs.core.apply.cljs$core$IFn$_invoke$arity$2"]],"^Z",[["^ ","^[",61,"^10",10,"^@","cljs.core/list"]],"~i41",[["^ ","^[",76,"^10",10]],"~i42",[["^ ","^[",76,"^10",10,"^@","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"~i46",[["^ ","^[",120,"^10",10,"^@","inner"]],"~i52",[["^ ","^[",126,"^10",10,"^@","form"]]],"^1<",["^ ","~i4",[["^ ","^[",3,"^10",13]],"~i5",[["^ ","^[",3,"^10",13,"^@","cljs.core/map-entry?"]],"~i16",[["^ ","^[",30,"^10",13,"^@","form"]],"^16",[["^ ","^[",0,"^10",14],["^ ","^[",4,"^10",14,"^@","G__11841"],["^ ","^[",0,"^10",15],["^ ","^[",0,"^10",15],["^ ","^[",82,"^10",15,"^@","G__11841"],["^ ","^[",110,"^10",15,"^@","G__11841"]],"^17",[["^ ","^[",8,"^10",15,"^@","outer"],["^ ","^[",46,"^10",15,"^@","outer"],["^ ","^[",94,"^10",15,"^@","outer"]],"^18",[["^ ","^[",15,"^10",14]],"^19",[["^ ","^[",15,"^10",14,"^@","cljs.core/vec"]],"~i34",[["^ ","^[",29,"^10",14]],"~i35",[["^ ","^[",29,"^10",14,"^@","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"~i39",[["^ ","^[",73,"^10",14,"^@","inner"]],"^14",[["^ ","^[",79,"^10",14,"^@","form"]]],"~i47",["^ ","~i4",[["^ ","^[",3,"^10",17]],"~i5",[["^ ","^[",3,"^10",17,"^@","cljs.core/seq?"]],"~i10",[["^ ","^[",24,"^10",17,"^@","form"]],"^16",[["^ ","^[",0,"^10",18],["^ ","^[",4,"^10",18,"^@","G__11842"],["^ ","^[",0,"^10",19],["^ ","^[",0,"^10",19],["^ ","^[",82,"^10",19,"^@","G__11842"],["^ ","^[",110,"^10",19,"^@","G__11842"]],"^17",[["^ ","^[",8,"^10",19,"^@","outer"],["^ ","^[",46,"^10",19,"^@","outer"],["^ ","^[",94,"^10",19,"^@","outer"]],"^18",[["^ ","^[",15,"^10",18]],"^19",[["^ ","^[",15,"^10",18,"^@","cljs.core.doall.cljs$core$IFn$_invoke$arity$1"]],"^Z",[["^ ","^[",61,"^10",18]],"~i37",[["^ ","^[",61,"^10",18,"^@","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"^1:",[["^ ","^[",105,"^10",18,"^@","inner"]],"^1B",[["^ ","^[",111,"^10",18,"^@","form"]]],"~i48",["^ ","~i4",[["^ ","^[",3,"^10",21]],"~i5",[["^ ","^[",3,"^10",21,"^@","cljs.core/record?"]],"~i13",[["^ ","^[",27,"^10",21,"^@","form"]],"^16",[["^ ","^[",0,"^10",22],["^ ","^[",4,"^10",22,"^@","G__11843"],["^ ","^[",0,"^10",25],["^ ","^[",0,"^10",25],["^ ","^[",82,"^10",25,"^@","G__11843"],["^ ","^[",110,"^10",25,"^@","G__11843"]],"^17",[["^ ","^[",8,"^10",25,"^@","outer"],["^ ","^[",46,"^10",25,"^@","outer"],["^ ","^[",94,"^10",25,"^@","outer"]],"^18",[["^ ","^[",15,"^10",22]],"^19",[["^ ","^[",15,"^10",22,"^@","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3"]],"^1D",[["^ ","^[",62,"^10",22],["^ ","^[",0,"^10",23]],"^1;",[["^ ","^[",73,"^10",22,"^@","r"]],"^13",[["^ ","^[",75,"^10",22,"^@","x"]],"^1B",[["^ ","^[",0,"^10",23]],"^1E",[["^ ","^[",7,"^10",23,"^@","cljs.core.conj.cljs$core$IFn$_invoke$arity$2"]],"~i53",[["^ ","^[",52,"^10",23,"^@","r"]],"~i55",[["^ ","^[",54,"^10",23]],"~i56",[["^ ","^[",55,"^10",23,"^@","inner"],["^ ","^[",93,"^10",23,"^@","inner"],["^ ","^[",134,"^10",23,"^@","inner"]],"~i62",[["^ ","^[",129,"^10",23,"^@","x"],["^ ","^[",150,"^10",23,"^@","x"]],"~i67",[["^ ","^[",3,"^10",24,"^@","form"]],"~i72",[["^ ","^[",8,"^10",24,"^@","form"]]],"~i49",["^ ","~i4",[["^ ","^[",3,"^10",27]],"~i5",[["^ ","^[",3,"^10",27,"^@","cljs.core/coll?"]],"^15",[["^ ","^[",25,"^10",27,"^@","form"]],"^16",[["^ ","^[",0,"^10",28],["^ ","^[",4,"^10",28,"^@","G__11844"],["^ ","^[",0,"^10",29],["^ ","^[",0,"^10",29],["^ ","^[",82,"^10",29,"^@","G__11844"],["^ ","^[",110,"^10",29,"^@","G__11844"]],"^17",[["^ ","^[",8,"^10",29,"^@","outer"],["^ ","^[",46,"^10",29,"^@","outer"],["^ ","^[",94,"^10",29,"^@","outer"]],"^18",[["^ ","^[",15,"^10",28]],"^19",[["^ ","^[",15,"^10",28,"^@","cljs.core.into.cljs$core$IFn$_invoke$arity$2"]],"^1@",[["^ ","^[",60,"^10",28]],"^Z",[["^ ","^[",60,"^10",28,"^@","cljs.core/empty"]],"^1;",[["^ ","^[",76,"^10",28,"^@","form"]],"^1E",[["^ ","^[",82,"^10",28]],"^1M",[["^ ","^[",82,"^10",28,"^@","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"^1G",[["^ ","^[",126,"^10",28,"^@","inner"]],"~i59",[["^ ","^[",132,"^10",28,"^@","form"]]],"~i50",["^ ","^16",[["^ ","^[",0,"^10",31]],"^17",[["^ ","^[",8,"^10",31,"^@","outer"],["^ ","^[",46,"^10",31,"^@","outer"],["^ ","^[",90,"^10",31,"^@","outer"]],"^18",[["^ ","^[",82,"^10",31,"^@","form"],["^ ","^[",106,"^10",31,"^@","form"]]],"^1=",["^ ","~i0",[["^ ","^[",0,"^10",39],["^ ","^[",24,"^10",44],["^ ","^[",0,"^10",45]],"~i6",[["^ ","^[",0,"^10",44,"^@","clojure.walk/postwalk"]]],"~i57",["^ ","~i3",[["^ ","^[",56,"^10",44,"^@","f"]],"~i5",[["^ ","^[",58,"^10",44,"^@","form"]]],"~i58",["^ ","~i2",[["^ ","^[",0,"^10",45]],"~i3",[["^ ","^[",7,"^10",45,"^@","clojure.walk/walk"]],"~i8",[["^ ","^[",25,"^10",45]],"~i9",[["^ ","^[",25,"^10",45,"^@","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]],"~i17",[["^ ","^[",73,"^10",45,"^@","clojure.walk/postwalk"]],"~i26",[["^ ","^[",95,"^10",45,"^@","f"]],"^18",[["^ ","^[",98,"^10",45,"^@","f"]],"~i31",[["^ ","^[",100,"^10",45,"^@","form"]]],"~i60",["^ ","~i0",[["^ ","^[",0,"^10",47],["^ ","^[",23,"^10",50],["^ ","^[",0,"^10",51]],"~i6",[["^ ","^[",0,"^10",50,"^@","clojure.walk/prewalk"]]],"~i63",["^ ","~i3",[["^ ","^[",54,"^10",50,"^@","f"]],"~i5",[["^ ","^[",56,"^10",50,"^@","form"]]],"~i64",["^ ","~i2",[["^ ","^[",0,"^10",51]],"~i3",[["^ ","^[",7,"^10",51,"^@","clojure.walk/walk"]],"~i8",[["^ ","^[",25,"^10",51]],"~i9",[["^ ","^[",25,"^10",51,"^@","cljs.core.partial.cljs$core$IFn$_invoke$arity$2"]],"^1R",[["^ ","^[",73,"^10",51,"^@","clojure.walk/prewalk"]],"~i25",[["^ ","^[",94,"^10",51,"^@","f"]],"~i28",[["^ ","^[",97,"^10",51,"^@","cljs.core/identity"]],"^1D",[["^ ","^[",116,"^10",51]],"~i38",[["^ ","^[",117,"^10",51,"^@","f"],["^ ","^[",151,"^10",51,"^@","f"],["^ ","^[",191,"^10",51,"^@","f"]],"~i40",[["^ ","^[",183,"^10",51,"^@","form"],["^ ","^[",203,"^10",51,"^@","form"]]],"~i66",["^ ","~i0",[["^ ","^[",0,"^10",53],["^ ","^[",31,"^10",56],["^ ","^[",0,"^10",57]],"~i6",[["^ ","^[",0,"^10",56,"^@","clojure.walk/keywordize-keys"]]],"~i69",["^ ","~i3",[["^ ","^[",70,"^10",56,"^@","m"]]],"~i70",["^ ","~i2",[["^ ","^[",0,"^10",57],["^ ","^[",0,"^10",67]],"~i8",[["^ ","^[",4,"^10",57,"^@","f"]],"^1C",[["^ ","^[",8,"^10",57],["^ ","^[",19,"^10",57,"^@","p__11845"],["^ ","^[",0,"^10",58],["^ ","^[",0,"^10",58],["^ ","^[",4,"^10",58,"^@","vec__11846"],["^ ","^[",17,"^10",58,"^@","p__11845"],["^ ","^[",8,"^10",59],["^ ","^[",8,"^10",59,"^@","cljs.core.nth.cljs$core$IFn$_invoke$arity$3"],["^ ","^[",52,"^10",59,"^@","vec__11846"],["^ ","^[",63,"^10",59],["^ ","^[",67,"^10",59],["^ ","^[",8,"^10",60],["^ ","^[",8,"^10",60,"^@","cljs.core.nth.cljs$core$IFn$_invoke$arity$3"],["^ ","^[",52,"^10",60,"^@","vec__11846"],["^ ","^[",63,"^10",60],["^ ","^[",67,"^10",60],["^ ","^[",0,"^10",61]],"^1>",[["^ ","^[",4,"^10",59,"^@","k"]],"~i18",[["^ ","^[",4,"^10",60,"^@","v"]],"^16",[["^ ","^[",0,"^10",61],["^ ","^[",0,"^10",62],["^ ","^[",0,"^10",64]],"^1S",[["^ ","^[",3,"^10",61]],"^1@",[["^ ","^[",10,"^10",61,"^@","k"]],"^1A",[["^ ","^[",90,"^10",62]],"^1[",[["^ ","^[",90,"^10",62,"^@","cljs.core.keyword.cljs$core$IFn$_invoke$arity$1"]],"^1E",[["^ ","^[",138,"^10",62,"^@","k"]],"~i51",[["^ ","^[",141,"^10",62,"^@","v"]],"^1H",[["^ ","^[",90,"^10",64,"^@","k"]],"^1P",[["^ ","^[",92,"^10",64,"^@","v"]]],"^1L",["^ ","~i4",[["^ ","^[",0,"^10",67]],"~i5",[["^ ","^[",7,"^10",67,"^@","clojure.walk/postwalk"]],"~i14",[["^ ","^[",29,"^10",67],["^ ","^[",0,"^10",69]],"~i19",[["^ ","^[",18,"^10",68,"^@","x"]],"^16",[["^ ","^[",0,"^10",69]],"^1S",[["^ ","^[",3,"^10",69]],"~i27",[["^ ","^[",3,"^10",69,"^@","cljs.core/map?"]],"~i32",[["^ ","^[",24,"^10",69,"^@","x"]],"^1@",[["^ ","^[",0,"^10",70],["^ ","^[",52,"^10",70]],"^Z",[["^ ","^[",7,"^10",70,"^@","cljs.core.into.cljs$core$IFn$_invoke$arity$2"]],"^13",[["^ ","^[",87,"^10",70]],"^14",[["^ ","^[",87,"^10",70,"^@","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"^1M",[["^ ","^[",131,"^10",70,"^@","f"]],"^24",[["^ ","^[",133,"^10",70,"^@","x"]],"^1H",[["^ ","^[",0,"^10",72,"^@","x"]],"^1N",[["^ ","^[",1,"^10",75,"^@","m"]]],"~i74",["^ ","~i0",[["^ ","^[",0,"^10",77],["^ ","^[",30,"^10",80],["^ ","^[",0,"^10",81]],"~i6",[["^ ","^[",0,"^10",80,"^@","clojure.walk/stringify-keys"]]],"~i77",["^ ","~i3",[["^ ","^[",68,"^10",80,"^@","m"]]],"~i78",["^ ","~i2",[["^ ","^[",0,"^10",81],["^ ","^[",0,"^10",91]],"~i8",[["^ ","^[",4,"^10",81,"^@","f"]],"^1C",[["^ ","^[",8,"^10",81],["^ ","^[",19,"^10",81,"^@","p__11849"],["^ ","^[",0,"^10",82],["^ ","^[",0,"^10",82],["^ ","^[",4,"^10",82,"^@","vec__11850"],["^ ","^[",17,"^10",82,"^@","p__11849"],["^ ","^[",8,"^10",83],["^ ","^[",8,"^10",83,"^@","cljs.core.nth.cljs$core$IFn$_invoke$arity$3"],["^ ","^[",52,"^10",83,"^@","vec__11850"],["^ ","^[",63,"^10",83],["^ ","^[",67,"^10",83],["^ ","^[",8,"^10",84],["^ ","^[",8,"^10",84,"^@","cljs.core.nth.cljs$core$IFn$_invoke$arity$3"],["^ ","^[",52,"^10",84,"^@","vec__11850"],["^ ","^[",63,"^10",84],["^ ","^[",67,"^10",84],["^ ","^[",0,"^10",85]],"^1>",[["^ ","^[",4,"^10",83,"^@","k"]],"^23",[["^ ","^[",4,"^10",84,"^@","v"]],"^16",[["^ ","^[",0,"^10",85],["^ ","^[",0,"^10",86],["^ ","^[",0,"^10",88]],"^1S",[["^ ","^[",3,"^10",85],["^ ","^[",17,"^10",85,"^@","cljs.core/Keyword"]],"^Z",[["^ ","^[",4,"^10",85,"^@","k"]],"^1[",[["^ ","^[",90,"^10",86]],"^1:",[["^ ","^[",90,"^10",86,"^@","cljs.core/name"]],"^1<",[["^ ","^[",105,"^10",86,"^@","k"]],"^1M",[["^ ","^[",108,"^10",86,"^@","v"]],"^1G",[["^ ","^[",90,"^10",88,"^@","k"]],"^1H",[["^ ","^[",92,"^10",88,"^@","v"]]],"~i80",["^ ","~i4",[["^ ","^[",0,"^10",91]],"~i5",[["^ ","^[",7,"^10",91,"^@","clojure.walk/postwalk"]],"^25",[["^ ","^[",29,"^10",91],["^ ","^[",0,"^10",93]],"^26",[["^ ","^[",18,"^10",92,"^@","x"]],"^16",[["^ ","^[",0,"^10",93]],"^1S",[["^ ","^[",3,"^10",93]],"^27",[["^ ","^[",3,"^10",93,"^@","cljs.core/map?"]],"^28",[["^ ","^[",24,"^10",93,"^@","x"]],"^1@",[["^ ","^[",0,"^10",94],["^ ","^[",52,"^10",94]],"^Z",[["^ ","^[",7,"^10",94,"^@","cljs.core.into.cljs$core$IFn$_invoke$arity$2"]],"^13",[["^ ","^[",87,"^10",94]],"^14",[["^ ","^[",87,"^10",94,"^@","cljs.core.map.cljs$core$IFn$_invoke$arity$2"]],"^1M",[["^ ","^[",131,"^10",94,"^@","f"]],"^24",[["^ ","^[",133,"^10",94,"^@","x"]],"^1H",[["^ ","^[",0,"^10",96,"^@","x"]],"^1N",[["^ ","^[",1,"^10",99,"^@","m"]]],"~i82",["^ ","~i0",[["^ ","^[",0,"^10",101],["^ ","^[",31,"^10",106],["^ ","^[",0,"^10",107]],"~i6",[["^ ","^[",0,"^10",106,"^@","clojure.walk/prewalk-replace"]]],"~i87",["^ ","~i3",[["^ ","^[",70,"^10",106,"^@","smap"]],"~i8",[["^ ","^[",75,"^10",106,"^@","form"]]],"~i88",["^ ","~i2",[["^ ","^[",0,"^10",107]],"~i3",[["^ ","^[",7,"^10",107,"^@","clojure.walk/prewalk"]],"^15",[["^ ","^[",28,"^10",107],["^ ","^[",0,"^10",108]],"^1>",[["^ ","^[",39,"^10",107,"^@","x"]],"^26",[["^ ","^[",0,"^10",108]],"^17",[["^ ","^[",3,"^10",108]],"~i24",[["^ ","^[",3,"^10",108,"^@","cljs.core/contains?"]],"^1?",[["^ ","^[",29,"^10",108,"^@","smap"]],"^1A",[["^ ","^[",34,"^10",108,"^@","x"]],"^1;",[["^ ","^[",0,"^10",109]],"^11",[["^ ","^[",8,"^10",109,"^@","smap"],["^ ","^[",45,"^10",109,"^@","smap"],["^ ","^[",85,"^10",109,"^@","smap"]],"^1E",[["^ ","^[",80,"^10",109,"^@","x"],["^ ","^[",100,"^10",109,"^@","x"]],"^24",[["^ ","^[",0,"^10",111,"^@","x"]],"^1H",[["^ ","^[",3,"^10",113,"^@","form"]]],"~i90",["^ ","~i0",[["^ ","^[",0,"^10",115],["^ ","^[",32,"^10",120],["^ ","^[",0,"^10",121]],"~i6",[["^ ","^[",0,"^10",120,"^@","clojure.walk/postwalk-replace"]]],"~i95",["^ ","~i3",[["^ ","^[",72,"^10",120,"^@","smap"]],"~i8",[["^ ","^[",77,"^10",120,"^@","form"]]],"~i96",["^ ","~i2",[["^ ","^[",0,"^10",121]],"~i3",[["^ ","^[",7,"^10",121,"^@","clojure.walk/postwalk"]],"~i12",[["^ ","^[",29,"^10",121],["^ ","^[",0,"^10",122]],"^1R",[["^ ","^[",40,"^10",121,"^@","x"]],"~i20",[["^ ","^[",0,"^10",122]],"^2@",[["^ ","^[",3,"^10",122]],"^1X",[["^ ","^[",3,"^10",122,"^@","cljs.core/contains?"]],"^1@",[["^ ","^[",29,"^10",122,"^@","smap"]],"^1[",[["^ ","^[",34,"^10",122,"^@","x"]],"^11",[["^ ","^[",0,"^10",123]],"^13",[["^ ","^[",8,"^10",123,"^@","smap"],["^ ","^[",45,"^10",123,"^@","smap"],["^ ","^[",85,"^10",123,"^@","smap"]],"^1M",[["^ ","^[",80,"^10",123,"^@","x"],["^ ","^[",100,"^10",123,"^@","x"]],"^1=",[["^ ","^[",0,"^10",125,"^@","x"]],"^1I",[["^ ","^[",3,"^10",127,"^@","form"]]]],"~:cljc",false],"~:cache-keys",["~#cmap",[["~:macro","^F"],[1532696035000],["^R","goog/math/math.js"],[1516644491000,"^G","~$goog.array","~$goog.asserts"],["^R","goog/array/array.js"],[1516644491000,"^G","^2K"],["^R","goog/debug/error.js"],[1516644491000,"^G"],["^R","goog/dom/nodetype.js"],[1516644491000,"^G"],["^R","goog/object/object.js"],[1516644491000,"^G"],"~:SHADOW-TIMESTAMP",[1538608779000,1532696035000],["^R","goog/math/long.js"],[1516644491000,"^G","^2K","~$goog.reflect"],["^R","goog/functions/functions.js"],[1516644491000,"^G"],["^R","clojure/walk.cljs"],[1532696035000,"^G","^F"],["^R","goog/structs/map.js"],[1516644491000,"^G","~$goog.iter.Iterator","~$goog.iter.StopIteration","~$goog.object"],["^R","goog/asserts/asserts.js"],[1516644491000,"^G","~$goog.debug.Error","~$goog.dom.NodeType","~$goog.string"],["^R","goog/uri/uri.js"],[1516644491000,"^G","^2J","^2K","^2S","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"],["^R","goog/base.js"],[1516644491000],["^R","goog/structs/structs.js"],[1516644491000,"^G","^2J","^2P"],["^R","goog/string/string.js"],[1516644491000,"^G"],["^R","goog/reflect/reflect.js"],[1516644491000,"^G"],["^R","goog/string/stringbuffer.js"],[1516644491000,"^G"],["^R","goog/iter/iter.js"],[1516644491000,"^G","^2J","^2K","~$goog.functions","~$goog.math"],["^R","cljs/core.cljs"],[1532696035000,"~$goog.math.Long","~$goog.math.Integer","^2S","^2P","^2J","~$goog.Uri","~$goog.string.StringBuffer"],["^R","goog/math/integer.js"],[1516644491000,"^G"],["^R","goog/uri/utils.js"],[1516644491000,"^G","^2J","^2K","^2S"]]],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","clojure/walk.cljs","^7",35,"^8",3,"^9",35,"^:",15,"^;","Stuart Sierra","^<","This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function."],"^=",null,"^>",["^?",[]],"^@","^A","^D",null,"^E",["^ ","^F","^F","^G","^G"],"^H",["^?",[]],"^I",null,"~:defs",["^ ","~$walk",["^ ","~:protocol-inline",null,"^5",["^ ","^6","clojure/walk.cljs","^7",37,"^8",7,"^9",37,"^:",11,"~:arglists",["^L",["~$quote",["^L",[["~$inner","~$outer","~$form"]]]]],"^<","Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.","~:added","1.1"],"^3<","1.1","^@","~$clojure.walk/walk","~:variadic",false,"^6","clojure/walk.cljs","^:",11,"~:method-params",["^L",[["^39","^3:","^3;"]]],"~:protocol-impl",null,"~:arglists-meta",["^L",[null,null]],"^8",1,"^7",37,"^9",37,"~:max-fixed-arity",3,"~:fn-var",true,"^37",["^L",["^38",["^L",[["^39","^3:","^3;"]]]]],"^<","Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."],"~$postwalk",["^ ","^36",null,"^5",["^ ","^6","clojure/walk.cljs","^7",53,"^8",7,"^9",53,"^:",15,"^37",["^L",["^38",["^L",[["~$f","^3;"]]]]],"^<","Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.","^3<","1.1"],"^3<","1.1","^@","~$clojure.walk/postwalk","^3>",false,"^6","clojure/walk.cljs","^:",15,"^3?",["^L",[["~$f","^3;"]]],"^3@",null,"^3A",["^L",[null,null]],"^8",1,"^7",53,"^9",53,"^3B",2,"^3C",true,"^37",["^L",["^38",["^L",[["~$f","^3;"]]]]],"^<","Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall."],"~$prewalk",["^ ","^36",null,"^5",["^ ","^6","clojure/walk.cljs","^7",61,"^8",7,"^9",61,"^:",14,"^37",["^L",["^38",["^L",[["~$f","^3;"]]]]],"^<","Like postwalk, but does pre-order traversal.","^3<","1.1"],"^3<","1.1","^@","~$clojure.walk/prewalk","^3>",false,"^6","clojure/walk.cljs","^:",14,"^3?",["^L",[["~$f","^3;"]]],"^3@",null,"^3A",["^L",[null,null]],"^8",1,"^7",61,"^9",61,"^3B",2,"^3C",true,"^37",["^L",["^38",["^L",[["~$f","^3;"]]]]],"^<","Like postwalk, but does pre-order traversal."],"~$keywordize-keys",["^ ","^36",null,"^5",["^ ","^6","clojure/walk.cljs","^7",67,"^8",7,"^9",67,"^:",22,"^37",["^L",["^38",["^L",[["~$m"]]]]],"^<","Recursively transforms all map keys from strings to keywords.","^3<","1.1"],"^3<","1.1","^@","~$clojure.walk/keywordize-keys","^3>",false,"^6","clojure/walk.cljs","^:",22,"^3?",["^L",[["~$m"]]],"^3@",null,"^3A",["^L",[null,null]],"^8",1,"^7",67,"^9",67,"^3B",1,"^3C",true,"^37",["^L",["^38",["^L",[["~$m"]]]]],"^<","Recursively transforms all map keys from strings to keywords."],"~$stringify-keys",["^ ","^36",null,"^5",["^ ","^6","clojure/walk.cljs","^7",75,"^8",7,"^9",75,"^:",21,"^37",["^L",["^38",["^L",[["~$m"]]]]],"^<","Recursively transforms all map keys from keywords to strings.","^3<","1.1"],"^3<","1.1","^@","~$clojure.walk/stringify-keys","^3>",false,"^6","clojure/walk.cljs","^:",21,"^3?",["^L",[["~$m"]]],"^3@",null,"^3A",["^L",[null,null]],"^8",1,"^7",75,"^9",75,"^3B",1,"^3C",true,"^37",["^L",["^38",["^L",[["~$m"]]]]],"^<","Recursively transforms all map keys from keywords to strings."],"~$prewalk-replace",["^ ","^36",null,"^5",["^ ","^6","clojure/walk.cljs","^7",83,"^8",7,"^9",83,"^:",22,"^37",["^L",["^38",["^L",[["~$smap","^3;"]]]]],"^<","Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.","^3<","1.1"],"^3<","1.1","^@","~$clojure.walk/prewalk-replace","^3>",false,"^6","clojure/walk.cljs","^:",22,"^3?",["^L",[["^3M","^3;"]]],"^3@",null,"^3A",["^L",[null,null]],"^8",1,"^7",83,"^9",83,"^3B",2,"^3C",true,"^37",["^L",["^38",["^L",[["^3M","^3;"]]]]],"^<","Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first."],"~$postwalk-replace",["^ ","^36",null,"^5",["^ ","^6","clojure/walk.cljs","^7",91,"^8",7,"^9",91,"^:",23,"^37",["^L",["^38",["^L",[["^3M","^3;"]]]]],"^<","Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.","^3<","1.1"],"^3<","1.1","^@","~$clojure.walk/postwalk-replace","^3>",false,"^6","clojure/walk.cljs","^:",23,"^3?",["^L",[["^3M","^3;"]]],"^3@",null,"^3A",["^L",[null,null]],"^8",1,"^7",91,"^9",91,"^3B",2,"^3C",true,"^37",["^L",["^38",["^L",[["^3M","^3;"]]]]],"^<","Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first."]],"^J",["^ ","^F","^F"],"~:cljs.analyzer/constants",["^ ","^H",["^?",["~:else"]],"~:order",["^3R"]],"^N",["^ "],"^O",["^ "],"^P",["^G","^F"]],"^C","^A","~:ns-specs",["^ "],"~:ns-speced-vars",[],"~:compiler-options",["^2H",[["^3V","~:static-fns"],true,["^3V","~:elide-asserts"],false,["^3V","~:optimize-constants"],null,["^3V","~:external-config"],null,["^3V","~:tooling-config"],null,["^3V","~:emit-constants"],null,["^3V","~:infer-externs"],true,["^3V","^W"],null,["~:js-options","~:js-provider"],"~:require",["~:mode"],"~:dev",["^3V","~:fn-invoke-direct"],null,["^3V","^Y"],"/dev/null"]]]